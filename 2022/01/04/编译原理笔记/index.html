<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"despairl.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Chap.1 编译器  编译器是一段程序，以某种源语言为输入，输出该语言翻译为目标语言的结果,一般会生成可执行的目标程序。  可以是程序语言-&gt;机器代码的过程，也可以是c++-&gt;python的过程   与编译器相比，解释器不生成中间程序，直接解释程序输入，边解释边执行。 编译器的结构可以分为两个部分：分析源程序信息加入符号表 与机器无关的前端以及根据符号表以及中间表示">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理笔记">
<meta property="og:url" content="https://despairl.github.io/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="YQBlog | HaveFun!">
<meta property="og:description" content="Chap.1 编译器  编译器是一段程序，以某种源语言为输入，输出该语言翻译为目标语言的结果,一般会生成可执行的目标程序。  可以是程序语言-&gt;机器代码的过程，也可以是c++-&gt;python的过程   与编译器相比，解释器不生成中间程序，直接解释程序输入，边解释边执行。 编译器的结构可以分为两个部分：分析源程序信息加入符号表 与机器无关的前端以及根据符号表以及中间表示">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031330468.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031315017.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201051521889.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031442739.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031442850.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031507862.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201051444568.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201051436498.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031552830.png">
<meta property="og:image" content="c:/Users/cyq/AppData/Roaming/Typora/typora-user-images/image-20220103155220779.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031552784.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031553033.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031553430.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031652200.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031653479.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031710192.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032126123.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031828634.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031852496.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031854120.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031900580.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031903975.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031922613.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031930449.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032123696.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032002078.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032009531.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032022932.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032026165.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032128051.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032131430.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032033980.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032100805.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041046430.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032215977.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041101645.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201052030526.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041102112.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201052033953.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201052040370.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041103047.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041206911.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201052118843.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041238783.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041239083.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041244243.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041403079.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041404200.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201052119444.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041421909.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041318730.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201052135266.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041335914.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041418346.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041343123.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041345828.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041345148.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041346087.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041436672.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041540688.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041545284.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041629046.png">
<meta property="og:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041641943.png">
<meta property="article:published_time" content="2022-01-04T11:57:31.306Z">
<meta property="article:modified_time" content="2022-01-06T12:15:52.336Z">
<meta property="article:author" content="Yanquan Chen">
<meta property="article:tag" content="Note">
<meta property="article:tag" content="CS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031330468.png">

<link rel="canonical" href="https://despairl.github.io/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>编译原理笔记 | YQBlog | HaveFun!</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">YQBlog | HaveFun!</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://despairl.github.io/2022/01/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yanquan Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQBlog | HaveFun!">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          编译原理笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-04 19:57:31" itemprop="dateCreated datePublished" datetime="2022-01-04T19:57:31+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-06 20:15:52" itemprop="dateModified" datetime="2022-01-06T20:15:52+08:00">2022-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-Note/" itemprop="url" rel="index"><span itemprop="name">CS Note</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="chap.1">Chap.1</h3>
<h4 id="编译器">编译器</h4>
<ul>
<li><p>编译器是一段程序，以<strong>某种源语言</strong>为输入，输出<strong>该语言翻译为目标语言</strong>的结果,一般会生成<strong>可执行的目标程序</strong>。</p>
<ul>
<li>可以是程序语言-&gt;机器代码的过程，也可以是c++-&gt;python的过程</li>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031330468.png" alt="image-20220103133017426" style="zoom:80%;" /></li>
</ul></li>
<li><p>与编译器相比，解释器不生成中间程序，<strong>直接解释程序输入</strong>，<strong>边解释边执行</strong>。</p></li>
<li><p>编译器的结构可以分为两个部分：分析源程序信息<strong>加入符号表</strong> <strong>与机器无关</strong>的<strong>前端</strong>以及根据符号表以及中间表示<strong>构造目标程序</strong>的<strong>与机器有关</strong>的<strong>后端</strong>。</p>
<ul>
<li>更具体来说，到<strong>中间代码生成为止</strong>，可以划分为<strong>前端</strong>。</li>
<li>从<strong>代码生成</strong>开始划分为<strong>后端</strong>。</li>
<li><strong>前端后端分开</strong>的好处：<strong>不同的源语言、不同的机器</strong>可以得到<strong>不同的编译器组合</strong> ,可以进行<strong>相同的中间代码优化</strong>。</li>
</ul>
<p><span id="more"></span></p></li>
<li><p>编译器执行的确定步骤为:</p>
<ul>
<li>由输入的源程序的<strong>字符流</strong>通过<strong>词法分析</strong>生成<strong>符号流</strong>，再通过<strong>语法分析、语义分析</strong>生成一棵<strong>语法树</strong>，通过<strong>中间代码生成器</strong>产生<strong>中间代码表示</strong>，用<strong>机器无关代码优化器</strong>进行优化，最终通过<strong>代码生成器</strong>产生<strong>目标机器语言</strong>，并利用<strong>机器相关代码优化器</strong>生成<strong>目标机器语言</strong>。</li>
<li>其中的信息用<strong>符号表</strong>进行保存，收集<strong>各种属性信息</strong>，可以<strong>由上述所有过程</strong>使用。</li>
<li>编译器划分多个阶段的原因在于，通过<strong>任务分解</strong> <strong>简化编译器的设计</strong>，<strong>提高编译器的效率</strong>，增强编译器的<strong>可移植性</strong>。</li>
</ul></li>
<li><p>词法分析</p>
<ul>
<li>分析输入的字符流，生成<strong>词素</strong>(lexeme),基于词素，生成<strong>词法单元</strong>,形式为<span class="math inline">\(&lt;token-name,attribute-name&gt;\)</span>,token-name可以给<strong>语法分析</strong>步骤使用，attribute-name指向<strong>相应的符号表条目</strong>，由<strong>语义分析/代码生成</strong>步骤使用。</li>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031315017.png" alt="image-20220103131554949" style="zoom:80%;" /></li>
</ul></li>
<li><p>语法分析</p>
<ul>
<li>语法分析<strong>接受</strong>词法分析输出的<strong>词法单元</strong>，根据token-name<strong>生成语法树</strong>，表明词法单元的<strong>语法结构</strong>。</li>
</ul></li>
<li><p>语义分析</p>
<ul>
<li>根据<strong>符号表以及语法树</strong>的信息，检查源程序<strong>是否满足语言定义的语义约束</strong>，同时，搜集<strong>类型信息</strong>，进行<strong>类型检查</strong>，<strong>类型转换</strong>,<strong>中间代码</strong> 的翻译。</li>
</ul></li>
<li><p>中间代码生成</p>
<ul>
<li>根据<strong>语义分析</strong>的输出，<strong>生成</strong>类机器语言的中间表示(通常是<strong>三地址代码</strong>,还有<strong>抽象语法树</strong>的形式）。</li>
<li>三地址代码：每个指令<strong>最多包含三个运算分量</strong></li>
</ul></li>
<li><p>机器无关代码优化器</p>
<ul>
<li><p>通过对中间代码的分析，<strong>改进中间代码</strong>，得到更好的目标代码</p>
<p>使之运行的<strong>更快</strong>、占用<strong>更少</strong>的内存：<strong>少占资源</strong></p></li>
</ul></li>
<li><p>代码生成器</p>
<ul>
<li>把<strong>中间代码表示</strong>形式<strong>映射到目标语言</strong>,<strong>分配寄存器、分配内存、选择指令</strong></li>
</ul></li>
<li><p>编译器的趟(Pass):</p>
<ul>
<li><strong>以文件为输入输出单位</strong>的编译过程的个数</li>
</ul></li>
<li><p>程序设计语言和编译器之间的关系：</p>
<ul>
<li>程序设计语言的发展<strong>向编译器提出新的要求</strong>，设计<strong>相应的算法和表示方法</strong>来<strong>翻译和支持新的语言特征</strong>，编译器的发展可以<strong>降低高级语言的执行开销</strong>。</li>
</ul></li>
</ul>
<h3 id="chap.3">Chap.3</h3>
<h4 id="词法分析器作用">词法分析器作用</h4>
<ul>
<li>读入源程序<strong>输入的字符流</strong>，生成<strong>词素</strong>(lexeme),基于<strong>词素</strong>，生成并输出<strong>词法单元</strong>，可以被<strong>供语法分析</strong>阶段使用。</li>
<li>一个常见的用法是
<ul>
<li>让语法分析器<strong>在需要时</strong>，调用，<strong>生成、传递词法单元</strong>，以<strong>避免额外的输入输出</strong>。</li>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201051521889.png" alt="image-20220105152116800" style="zoom:80%;" /></li>
</ul></li>
<li>常见的构造方式：
<ul>
<li>手工编写代码扫描输入中的每个词素</li>
<li>使用词法分析器生成工具（如lex flex）。</li>
</ul></li>
</ul>
<h5 id="词法单元及相关概念">词法单元及相关概念</h5>
<ul>
<li>词法单元（Token）:
<ul>
<li>形式为<span class="math inline">\(&lt;token-name,attribute-value&gt;\)</span>,token-name是某种<strong>词法单位抽象符号</strong>，attribute-value为<strong>属性值</strong>。</li>
<li><strong>属性值</strong>被用于<strong>语义分析、代码生成</strong>等阶段。不同的目的需要不同的属性。因此，属性值通常是一个<strong>结构化</strong>数据。例如，记录类型、位置等。</li>
</ul></li>
<li>词素（Lexeme）:
<ul>
<li>源程序中的<strong>字符序列</strong>,<strong>与模式匹配</strong>，被词法分析器识别为该词法单元的<strong>实例</strong>。</li>
</ul></li>
<li>模式（Pattern）：
<ul>
<li>描述<strong>词素的形式</strong>，一般为<strong>正则表达式</strong>。</li>
</ul></li>
<li>字母表：
<ul>
<li>表示一个<strong>有限的符号集合</strong>。</li>
</ul></li>
<li>串
<ul>
<li>用<strong>字母表</strong>中的符号组成的<strong>有穷</strong>集合。</li>
<li>有连接运算以及幂次运算，幂次：相同的连接。</li>
</ul></li>
<li>前缀、后缀，子串：
<ul>
<li>按照常见定义的串中<strong>连续</strong>的一段集合。</li>
<li>真前缀、真后缀，真子串表示与原串不同。</li>
<li>规范定义是：去掉<strong>串头部或者尾部</strong>的几个字母。</li>
</ul></li>
<li>子序列：
<ul>
<li>串中的一段集合，可以是<strong>非连续</strong>的。</li>
</ul></li>
<li>语言：
<ul>
<li>给定<strong>字母表上一个任意的可数的串</strong>的集合</li>
<li>有并运算、连接运算、Kleene闭包（包含空集的<span class="math inline">\(L^i\)</span>构成的集合）、正闭包（不包含空集的<span class="math inline">\(L^i\)</span>构成的集合）</li>
</ul></li>
</ul>
<h4 id="正则表达式re">正则表达式(RE)</h4>
<ul>
<li><p>每个正则表达式r可以描述一个语言L(r)，也即其定义的正则集合。</p></li>
<li><p>正则表达式的运算:</p>
<ul>
<li><p>对于某个符号或者空符号<span class="math inline">\(f\)</span>: <span class="math display">\[
  L(f) = \{f\}
  \]</span></p></li>
<li><p>选择 <span class="math display">\[
  L(r|s) = L(r) \cup L(s)
  \]</span></p></li>
<li><p>连接 <span class="math display">\[
  L(rs) = L(r)L(s)
  \]</span></p></li>
<li><p>闭包 <span class="math display">\[
  L(r^*) = L(r) ^*
  \]</span></p>
<ul>
<li>闭包含有幂等性<span class="math inline">\(** = *\)</span></li>
</ul></li>
<li><p>括号 <span class="math display">\[
  L((r)) = L(r)
  \]</span></p></li>
<li><p>优先级方面: <span class="math inline">\(*\)</span>&gt;连接&gt;选择</p></li>
<li><p>等价性 <span class="math display">\[
  L(r) = L(s),L=s
  \]</span></p></li>
<li><p>一个或多个<span class="math inline">\(+\)</span>: <span class="math display">\[
  L(r^+) = L(r)L(r^*)
  \]</span></p></li>
<li><p>零个或多个<span class="math inline">\(?\)</span>: <span class="math display">\[
  L(r?) = L(\epsilon|r) = L(r) \cup L(\epsilon)
  \]</span></p></li>
<li><p><span class="math inline">\([]\)</span>: <span class="math display">\[
  L([abc]) = L([a-c]) = L(a|b|c)
  \]</span></p></li>
</ul></li>
<li><p>利用正则表达式可以对字母表中的符号进行<strong>正则定义</strong>。 <span class="math display">\[
  symbol \rightarrow RE
  \]</span></p></li>
</ul>
<h4 id="词法单元的识别">词法单元的识别</h4>
<ul>
<li>首先<strong>通过正则定义</strong>来<strong>描述各种词法单元</strong>的模式</li>
<li>词法分析器可以<strong>将正则表达式转换成状态转换图</strong>:
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031442739.png" alt="image-20220103144223700" style="zoom:80%;" /> 表示开始状态</li>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031442850.png" alt="image-20220103144247803" style="zoom:80%;" /> 表示每一个可能状态，<strong>接收状态为两个圈</strong>，如果两个圈加*表示识别的内容不在词素中。</li>
</ul></li>
<li>词法分析中<strong>对于保留字以及标识符</strong>会进行<strong>优先识别</strong>，<strong>事先建立单独的状态转换图</strong>。</li>
<li>通过switch以及state变量就可以通过转换图构造词法分析器。
<ul>
<li><strong>每个状态对应于一段代码</strong></li>
<li>如果<strong>找不到相应的边</strong>，则调用fail()</li>
<li>进入某个接受状态时，返回<strong>相应的词法单元</strong></li>
<li>有*标记时，需要回退forward指针</li>
</ul></li>
</ul>
<h4 id="有穷自动机-fa">有穷自动机 FA</h4>
<ul>
<li><p><strong>本质上与状态转换图等价</strong></p></li>
<li><p>区别在于自动机是<strong>识别器</strong>，对<strong>每个输入串回答yes or no</strong></p>
<ul>
<li><p>分为NFA,DFA,都可以识别RE，每个NFA存在等价转换为DFA的方式</p></li>
<li><p>NFA与DFA的区别在于（<strong>确定性以及不确定性</strong>）:</p>
<ul>
<li><p>一个符号<strong>标记</strong>离开同一状态的<strong>多条边</strong> vs</p>
<p>对于<strong>每个状态</strong>和字母表中的<strong>每个字符</strong>，<strong>有且仅有 一条离开该状态、以该符号为标号的边</strong>:</p>
<ul>
<li>意为对于每个状态，<strong>一个标记</strong>对应<strong>一个目标状态</strong></li>
</ul></li>
<li><p><strong>可以</strong>有边的标号是ε vs</p>
<p><strong>没有</strong>标记为ε的边</p></li>
</ul></li>
</ul></li>
<li><p>NFA可以表示为一个转换表:</p>
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031507862.png" alt="image-20220103150706793" style="zoom:80%;" />
<ul>
<li>表中元素表示可以前往的状态。</li>
</ul></li>
<li>NFA的模拟,需要用到子集构造法:
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201051444568.png" alt="image-20220105144430509" style="zoom:80%;" />
<ul>
<li>与DFA的区别就在于，<strong>NFA</strong>需要<strong>闭包</strong>运算，<strong>DFA不用</strong>。</li>
</ul></li>
</ul></li>
<li>一个NFA<strong>接受</strong>输入字符串x<strong>输出yes</strong>，<strong>当且仅当</strong>对应的转换图中<strong>存在一条</strong>从开始状态到某个接受状态的路径，使得该路径中<strong>各条边上的标号组成符号串x</strong> 。 （路径中可能包含ε 边）
<ul>
<li>从开始状态到某个接受状态的所有路径上的符号串集合，称为接受的语言集合<em>L(A)</em></li>
</ul></li>
</ul></li>
<li><p>DFA:</p>
<ul>
<li>可以高效判断一个串能否被一个DFA接受.
<ul>
<li>一个输入可以<strong>走向确定的状态</strong></li>
</ul></li>
<li>DFA的模拟：
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201051436498.png" alt="image-20220105143610415" style="zoom:80%;" /></li>
<li>F是<strong>状态集合S</strong>的子集，s在F中表示<strong>接受状态</strong></li>
</ul></li>
<li><strong>正则表达式</strong>可以表示<strong>词法单元的模式</strong>，但<strong>模式匹配</strong>的过程需要DFA的帮助。因此，需要把<strong>正则表达式转为DFA</strong>。一般会先把<strong>正则表达式转为NFA,再将NFA转为DFA</strong>。</li>
<li><strong>将NFA转为DFA</strong>——子集构造法:<span class="math inline">\(\color{red}{Key}\)</span>
<ul>
<li><span class="math inline">\(\epsilon-closure(x)\)</span>:从x出发<strong>只通过<span class="math inline">\(\epsilon\)</span></strong>可以达到的状态集合,<span class="math inline">\(\color{red}{包含x本身}\)</span> 。</li>
</ul></li>
<li><span class="math inline">\(move(x,y)\)</span>:从x状态出发，通过y边可以抵达的状态集合。
<ul>
<li>以<span class="math inline">\(\epsilon-closure(0)\)</span>为初始状态</li>
<li>之后<strong>尝试所有非空输入边x</strong>，<span class="math inline">\(\epsilon-closure(move(T,x))\)</span>生成一个新状态<span class="math inline">\(T_1\)</span> <span class="math inline">\(\color{red}{注意这里有两步，求转移状态+求闭包}\)</span></li>
<li>然后对新状态尝试所有非空输入边x，<strong>直到不再生成新状态</strong></li>
</ul></li>
</ul></li>
<li><p>DFA状态数最小化:对DFA进行化简<span class="math inline">\(\color{red}{Key}\)</span></p>
<ul>
<li>如果分别从状态s和状态t出发，沿着标号为x的路径到达的<strong>两个状态只有一个是接受状态</strong>，称为<strong>x区分状态s和t</strong>。</li>
<li>最小化的过程：
<ul>
<li>按照接受与否，将状态划分为<strong>接受状态集</strong>以及<strong>其他状态集</strong></li>
<li>对于<strong>其他状态集</strong>,寻找可以区分其他状态集的边,并按照区分进行分割<span class="math inline">\(Set_1,Set_2\)</span>,也就是通过<strong>一个串</strong>拆分为<strong>可以抵达接受态</strong>和<strong>不可抵达接受态</strong>。</li>
<li>对于<span class="math inline">\(Set_1,Set_2\)</span>重复上步，直至<strong>无状态可分</strong>。 (<strong>划分</strong>)</li>
<li>从每个集合中<strong>选取一个代表</strong>，组成<strong>化简后的DFA</strong>。 (<strong>构造</strong>)</li>
</ul></li>
</ul></li>
<li><p>正则表达式到NFA:</p>
<ul>
<li><p>按照一定模式，进行转换。<span class="math inline">\(\color{red}{记一记就好}\)</span></p></li>
<li><figure>
<img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031552830.png" alt="image-20220103155207777" /><figcaption aria-hidden="true">image-20220103155207777</figcaption>
</figure></li>
<li><figure>
<img src="C:\Users\cyq\AppData\Roaming\Typora\typora-user-images\image-20220103155220779.png" alt="image-20220103155220779" /><figcaption aria-hidden="true">image-20220103155220779</figcaption>
</figure></li>
<li><p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031552784.png" alt="image-20220103155237711" style="zoom:67%;" /></p></li>
<li><p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031553033.png" alt="image-20220103155339977" style="zoom:67%;" /></p></li>
<li><p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031553430.png" alt="image-20220103155353369" style="zoom:67%;" /></p></li>
</ul></li>
</ul>
<h3 id="chap.4">Chap.4</h3>
<h4 id="语法分析器">语法分析器</h4>
<ul>
<li>词法分析器输出的<strong>词法单元序列作为输入</strong>，输出<strong>语法树表示</strong>,<strong>用于验证输入源程序的合法性并输出良构程序的语法结构；对于病构的程序，能够报告语法错误</strong>，<strong>并进行错误回复</strong>
<ul>
<li>通用型 CKY</li>
<li><strong>top-down</strong> : 处理LL文法</li>
<li>bottom-up : 处理LR文法</li>
</ul></li>
</ul>
<h5 id="文法">文法</h5>
<ul>
<li><p>这里一般指<strong>上下文无关文法</strong> （Context Free Grammar, CFG）。</p>
<ul>
<li><p>由于程序设计语言中往往<strong>存在嵌套结构</strong>，因此，上下文无关文法是一种描述的好方式。</p></li>
<li><p>上下文无关文法由以下部分组成</p>
<ul>
<li><p>终结符号 : 小写字母或者类似id的形式</p></li>
<li><p>非终结符号 ： 大写字母</p></li>
<li><p>产生式 “→”,又称为<strong>重写规则</strong>，进行了一个<strong>推导</strong></p>
<ul>
<li><strong>产生式到终结符号</strong>的过程，表明了该<strong>终结符号是产生式的一个实例</strong>。</li>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031652200.png" alt="image-20220103165244153" style="zoom:50%;" /> 表示<strong>零步或多步</strong>推导过程。</li>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031653479.png" alt="image-20220103165343440" style="zoom:67%;" /> 表示<strong>一步或多步</strong>推导过程。</li>
</ul></li>
<li><p>开始符号 : <em>S</em></p>
<ul>
<li><p>如果从文法的开始符号S开始,经过<strong>零步或多步</strong>推导，得到<span class="math inline">\(\alpha\)</span>，那么就称<span class="math inline">\(\alpha\)</span>是文法G的一个<strong>句型</strong>。</p></li>
<li><p><strong>不包括非终结符号</strong>的句型就是句子。</p></li>
<li><p>语言，则是<strong>句子的集合</strong>,由文法<em>G</em>生成的语言(<strong>句子的集合</strong>)被称为<strong>上下文无关语言<em>L(G)</em></strong> 。换言之，语言是<strong>由文法的开始符号</strong>出发，能够推导得到的<strong>所有句子的集合</strong>。</p></li>
<li><p>两个文法<strong>生成相同语言</strong>，则两文法等价</p></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>从文法推导的角度理解:</p>
<ul>
<li>语法分析的任务是：<strong>接受一个终结符号串</strong>作为输入，找出<strong>从文法的开始符号推导出这个串</strong>的方法。
<ul>
<li>这样的推导方式也就是top-down的分析方式。</li>
</ul></li>
<li>推导中可能遇到的<strong>两个问题</strong>为:
<ul>
<li><strong>非终结符号的替换顺序</strong>是什么</li>
<li>若以这个非终结符号为头的<strong>产生式有多个</strong>，<strong>该用哪个产生式</strong>的右部替换</li>
</ul></li>
<li>一般的解决方式是<strong>最左推导</strong>或者<strong>最右推导</strong>。
<ul>
<li><strong>最左推导</strong>：总是选择每个句型的<strong>最左非终结</strong>符号，记为<span class="math inline">\(\rightarrow_{lm}\)</span></li>
<li><strong>最右推导</strong>：总是选择<strong>最右</strong>边的<strong>非终结</strong>符号，记为<span class="math inline">\(\rightarrow_{rm}\)</span></li>
</ul></li>
<li>通过<strong>最左推导</strong>生成的句型为<strong>最左句型</strong>。</li>
<li>可以将推导的过程表示成<strong>语法分析树</strong>的形式。</li>
</ul></li>
</ul>
<h5 id="与词法分析相比">与词法分析相比</h5>
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031710192.png" alt="image-20220103171051108" style="zoom:67%;" /></li>
<li>正则表达式适合描述<strong>词法结构</strong>，文法适合描述<strong>嵌套结构</strong></li>
<li><strong>文法比正则表达式</strong>描述能力更<strong>强</strong>
<ul>
<li><strong>每个正则表达式</strong>都可以用一个<strong>上下文无关文法来描述</strong>，反之不成立</li>
</ul></li>
<li><strong>正则表达式</strong>描述词法单元比较<strong>简洁</strong>,基于正则表达式构造的词法分析器<strong>效率更高</strong></li>
</ul>
<h5 id="在语法分析之前">在语法分析之前</h5>
<ul>
<li><p>在进行高效的语法分析之前，需要对文法做以下处理:</p>
<ul>
<li><p><strong>消除二义性</strong>:</p>
<ul>
<li><p>二义性是一个文法可以生成多个语法分析树</p></li>
<li><p>消除二义性的方法有<strong>基于优先级</strong>消除二义性以及<strong>基于语义解释消除</strong>二义性。</p></li>
<li><p>注意的一点是<span class="math inline">\(\color{red}{后计算的产生式运算优先级更高}\)</span></p>
<p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032126123.png" alt="image-20220103212645081" style="zoom:80%;" /></p></li>
<li><p>对于if-else，要明确地指出哪些句子是matched，哪些是open的，不然一定存在二义性。</p></li>
</ul></li>
<li><p><strong>消除左递归</strong>：</p>
<ul>
<li>原因在于<strong>自顶向下的语法分析技术</strong> <strong>不能处理</strong>左递归的文法:
<ul>
<li><strong>自顶向下的语法分析技术</strong>:从一个<strong>开始符号开始</strong>推导到<strong>最后的终结符号串</strong>。</li>
</ul></li>
<li>立即左递归： <span class="math inline">\(A\rightarrow A\alpha\)</span></li>
<li>左递归则是<span class="math inline">\(A\)</span>通过一步或者多步推导生成了<span class="math inline">\(A\alpha\)</span>。</li>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031828634.png" alt="image-20220103182846560" style="zoom: 50%;" /></li>
<li>对于非立即左递归的左递归消除算法：
<ul>
<li>对所有的非终结符号<strong>按照产生顺序</strong>进行排序<span class="math inline">\(A_1,A_2,...,A_n\)</span></li>
</ul></li>
<li>对于<span class="math inline">\(A_i-&gt;A_j\)</span>,<span class="math inline">\(j&gt;i\)</span>,那么不会出现左递归的情况
<ul>
<li>反之，如果<span class="math inline">\(A_i-&gt;A_k\)</span>,<span class="math inline">\(k&lt;i\)</span>,就将<span class="math inline">\(A_k\)</span>按照产生式不断展开，那么就可以化成<span class="math inline">\(A_i-&gt;A_j\)</span>,<span class="math inline">\(j&gt;i\)</span>的情况。</li>
</ul></li>
<li>之后，按照消除立即左递归的思路处理一遍就可以。</li>
</ul></li>
</ul></li>
<li><p>提取左公因子</p>
<ul>
<li><p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031852496.png" alt="image-20220103185218444" style="zoom:80%;" /></p>
<ul>
<li><p>对于每个非终结符号<em>A</em>，找出它的两个或多个可选项之间的最长公共前缀<em>α</em>，且<em>α<strong>≠</strong>ε</em> ,之后进行下述展开</p>
<p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031854120.png" alt="image-20220103185420057" style="zoom:67%;" /></p></li>
</ul></li>
</ul></li>
</ul>
<h4 id="自顶向下分析">自顶向下分析</h4>
<ul>
<li><p><strong>自顶向下分析</strong>可以被看作是<strong>为输入串构造语法分析树</strong>的问题,也可以看作一个<strong>寻找输入串的最左推导</strong>的过程,从一个<strong>开始符号开始</strong>推导到<strong>最后的终结符号串</strong>。</p></li>
<li><p>自顶向下分析的伪代码描述（或者说是<strong>递归下降</strong>）：</p>
<ul>
<li><p><strong>通用的递归下降分析</strong>框架:</p>
<ul>
<li>由<strong>一组过程</strong>组成，每个非终结符号对应一个过程。选择一个产生式体，<strong>扫描相应的句子</strong>。若遇到<strong>非终结符号</strong>，<strong>调用该符号对应的过程</strong>。</li>
</ul></li>
<li><p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031900580.png" alt="image-20220103190040522" style="zoom:80%;" /></p></li>
<li><p>简单来说就是<strong>不断展开非终结符号</strong>,<strong>读入下一个输入符号</strong>，直到遇到输入符号<span class="math inline">\(a\)</span> 。</p>
<ul>
<li>读入输入符号a,a是<strong>不会重复读入</strong>的。</li>
</ul></li>
<li><p>但是对于<strong>有多个产生式的非终结符号</strong>，上述的伪代码<strong>无法有效处理</strong>选择问题。</p>
<p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031903975.png" alt="image-20220103190327898" style="zoom:80%;" /></p></li>
<li><p>为了处理这个问题，就需要<strong>预测分析技术</strong>:</p>
<ul>
<li>通过在输入中<strong>向前看固定多个符号</strong>来选择正确的产生式,通常情况下，我们<strong>只需要向前看一个符号</strong>:</li>
<li>与文法相关的两个函数:
<ul>
<li>FIRST<span class="math inline">\((\alpha)\)</span> : 可从<strong>α推导得到的串的首符号</strong>的集合,<strong>可以包含<span class="math inline">\(\epsilon\)</span></strong> ,主要作用于<strong>分支选取</strong>。
<ul>
<li>如果X是<strong>终结符号</strong>，那么FIRST(X)={X}</li>
<li>如果X是<strong>非终结符号</strong>，且有规则X <em>→</em> a…,那么将a添加到FIRST(X)中。</li>
<li>如果X <em>→</em> ε，那么ε也在FIRST(X)中。</li>
<li>对于产生式X<em>→</em> Y1Y2…Yn,把FIRST(Y1)中的非ε符号添加到FIRST(X)中。如果<strong>ε在FIRST(Y1)中</strong>，把<strong>FIRST(Y2)中的非ε符号</strong>添加到<strong>FIRST(X)</strong>中;如果ε在FIRST(Y1),FIRST(Y2)中,把FIRST(Y3)中的非ε符号添加到FIRST(X)中，<strong>以此类推</strong>，如果ε在FIRST(Y1),FIRST(Y2),...,FIRST(Yn)中，把ε添加到FIRST(X)中。
<ul>
<li><strong>ε在FIRST(Y1)中,说明X <em>→</em> ε</strong></li>
</ul></li>
<li>特别的，例如，对于两个非终结符号串<span class="math inline">\(E-&gt;TAFA\)</span>,<span class="math inline">\(FIRST(E) = FIRST(TAFA) = FIRST(T)\)</span><br />
</li>
</ul></li>
<li>FOLLOW(A):
<ul>
<li>对于非终结符号<em>A</em>，FOLLOW(<em>A</em>)定义为可能在某些句型中<strong>紧跟在<em>A</em>右边的终结符号</strong>的集合。</li>
<li>如果A是某些句型的最右符号，那么<span class="math inline">\(\$ ∈Follow(A)\)</span> $是特殊的输入串“结束标记”</li>
<li>计算规则:
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031922613.png" alt="image-20220103192253522" style="zoom:80%;" /></li>
<li>对于E-&gt;TG, <strong>FOLLOW(T) = FIRST(G) <span class="math inline">\(\cup\)</span> FOLLOW(G)</strong>
<ul>
<li>一般计算FOLLOW(A)需要<strong>找A所在的产生式的体</strong>。</li>
<li>如果<strong>FIRST(A)含有</strong><span class="math inline">\(\epsilon\)</span>,就找产生式的头E的FOLLOW(E)</li>
<li>对于<strong>处于产生式的体中间</strong>的非终结符号，需要按FIRST(G) <span class="math inline">\(\cup\)</span> FOLLOW(G)的公式计算。</li>
<li>一般不计入<span class="math inline">\(\epsilon\)</span></li>
</ul></li>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201031930449.png" alt="image-20220103193036384" style="zoom:80%;" /></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="ll1文法">LL(1)文法</h4>
<ul>
<li><p>如果对于文法G的任意两个不同的产生式<span class="math inline">\(A\rightarrow \alpha|\beta\)</span> :</p>
<ul>
<li><span class="math inline">\(FIRST(\alpha)\cap FIRST(\beta) = \emptyset\)</span>
<ul>
<li>向前看一个输入符号选择产生式的需要。</li>
</ul></li>
<li><span class="math inline">\(\alpha \rightarrow^* \epsilon,\beta\rightarrow^* \epsilon\)</span>不能同时成立</li>
<li>如果<span class="math inline">\(\beta\rightarrow^* \epsilon\)</span>,那么<span class="math inline">\(FIRST(\alpha)\cap FOLLOW(A) = \emptyset\)</span></li>
</ul>
<p>就称该文法为LL(1)文法。</p>
<p><strong>第一个L</strong>表示<strong>自左向右扫描</strong>，<strong>第二个L</strong>指<strong>产生最左推导</strong>，而1则表示<strong>向前看一个输入符号</strong>。<span class="math inline">\(\color{red}{Key}\)</span></p></li>
<li><p><strong>LL(1)文法+无左递归可以使用</strong>上述预测分析技术,并将first和follow集合中的信息放入一个预测分析表M[A,a]，该预测表告诉我们<strong>当非终结符号为A，当前输入符号为a时，要选择哪条产生式。</strong></p>
<ul>
<li><strong>无左递归、无二义性</strong>才能用<strong>自顶向下的语法分析</strong></li>
</ul></li>
<li><p><strong>构造预测分析表</strong>:</p>
<ul>
<li>对于文法<em>G</em>的每个产生式<em>A</em> <em>→</em> <em>α</em> ：
<ul>
<li>对于First(<em>α</em>)中的<strong>每个终结符号</strong>a，将<em>A</em> <em>→</em> <em>α</em>加入到<em>M[<strong>A,a</strong>]</em></li>
<li>如果ε在First<em>(<strong>α</strong>)</em>中，那么对于Follow(A)中的<strong>每个终结符号</strong>b，将<em>A</em> <em>→</em> <em>α</em>加入到<em>M[<strong>A,b</strong>]</em>中</li>
<li>如果ε在First<em>(<strong>α</strong>)</em>中，且$在Follow(A)中，将<em>A</em> <em>→</em> <em>α</em>加入到<em>M[A,$]</em>中</li>
<li><span class="math inline">\(\color{red}{换言之}\)</span>,将<em>A</em> <em>→</em> <em>α</em>加入到M[A,First(α)]中；对于可以推导出<span class="math inline">\(\epsilon\)</span>的产生式<em>A</em> <em>→</em> <em>α</em>，将<em>A</em> <em>→</em> <em>α</em>加入到M[A,Follow(A)]中。<span class="math inline">\(\color{red}{Key}\)</span> <span class="math inline">\(\color{red}{一般后一种情况的产生式为A\rightarrow\epsilon}\)</span>
<ul>
<li><strong>对于产生式A -&gt; a，如果FIRST(a)不含ε，则在所有的(A,FIRST(a))处写上这条产生式；如果含ε，还要在(A,FOLLOW(A))处补上这条产生式。</strong></li>
</ul></li>
</ul></li>
<li>若<em>M[<strong>A,a</strong>]</em>中没有产生式，填为error</li>
</ul></li>
<li><p>尽管<strong>所有文法都可以构造</strong>预测分析表，但是无法保证像<strong>LL(1)文法</strong>一样表达式选择是<strong>唯一</strong>的</p></li>
<li><p>LL(1)与递归下降：</p>
<ul>
<li>对于<strong>LL(1)文法</strong>，如何改造递归下降程序，使之能够避免回溯?</li>
<li>一般的递归下降算法为
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032123696.png" alt="image-20220103212344641" style="zoom:80%;" /></li>
<li>这里的关键点在于<span class="math inline">\(\color{red}{读入一个输入符号之后，即使发生错误，也不会回退，因此，作业题中不能识别aaaaaa}\)</span></li>
</ul></li>
</ul></li>
<li><p>预测分析的示例:</p>
<p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032002078.png" alt="image-20220103200214969" style="zoom:80%;" /></p>
<p>步骤大概就是:</p>
<ul>
<li>消除左递归、二义性、提取左公因子</li>
<li>生成FIRST，FOLLOW</li>
<li>生成预测分析表</li>
<li>画出类似上图的栈结构</li>
</ul></li>
</ul>
<h4 id="自底向上分析">自底向上分析</h4>
<ul>
<li>自底向上语法分析过程对应于<strong>为一个输入串构造语法分析树</strong>的过程,也是将一个串<em>w</em><strong>归约</strong>为<strong>文法符号S</strong>的过程,也是<strong>反向最右推导</strong>过程，也是<strong>句柄</strong>剪枝过程。从叶子节点（底部）开始逐渐向上到达根节点（顶部）。<strong>归约</strong>可以看成<strong>推导的逆过程</strong>。问题在于:
<ul>
<li>什么时候规约</li>
<li>选择哪一个产生式</li>
</ul></li>
<li>句柄：<strong>和某个产生式体相匹配</strong>的<strong>子串</strong>，<strong>对它的归约</strong>代表了<strong>相应的最右推导</strong>的一个<strong>反向</strong>步骤。要<strong>从最右句型的<span class="math inline">\(\color{red}{最左边}\)</span></strong>开始找。<span class="math inline">\(\color{red}{Key}\)</span>
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032009531.png" alt="image-20220103200937478" style="zoom:80%;" /></li>
</ul></li>
<li>问题就被转变为如何去寻找句柄。</li>
</ul>
<h5 id="移进归约语法分析框架">移进归约语法分析框架</h5>
<ul>
<li><p>有四种动作：</p>
<ul>
<li>移进：将输入的一个符号移入栈
<ul>
<li>初始栈只含$</li>
</ul></li>
<li>规约：对栈中符号按照产生式规约
<ul>
<li>这样，移进规约的过程就与寻找句柄的过程<strong>相通</strong>了。</li>
</ul></li>
<li>接受: 最终栈为$S ,S 为开始符号</li>
<li>报错</li>
</ul></li>
<li><p><span class="math inline">\(\color{red}{说明相应的自底向上语法分析过程，只需要给出移进规约的表即可}\)</span></p></li>
<li><p>无法处理部分文法，比如二义性文法,会产生冲突。</p></li>
<li><p>为了解决这种冲突，我们需要使用<strong>LR语法分析技术（SLR分析）</strong>。</p>
<ul>
<li><p>如果能够用某个方法<strong>为一个文法构造出移进-归约语法分析表</strong>，那么就称为LR文法</p>
<ul>
<li>LR(k)分析:
<ul>
<li>L : 从左往右扫描输入</li>
<li>R: <strong>反向构造</strong>一个最右推导序列</li>
<li>k: 向前看k个符号</li>
</ul></li>
</ul></li>
<li><p>定义LR(0)项(item)：一个文法G的一个LR(0)项是G的<strong>一个产生式</strong>再<strong>加上一个位于它的体中某处的点</strong>。</p>
<p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032022932.png" alt="image-20220103202230887" style="zoom:80%;" /></p></li>
<li><p>项的集合（项集）<strong>对应于一个状态</strong></p></li>
<li><p>定义增广文法:</p>
<ul>
<li>在文法<em>G</em>上增加一个产生式<em>S’</em> →<em>S</em></li>
<li>目的是告诉语法分析器<strong>何时宣布接受输入符号串</strong>。<strong>即用<em>S’</em> →<em>S</em>进行归约时，表明分析结束</strong> <span class="math inline">\(\color{red}{Key}\)</span></li>
</ul></li>
<li><p>定义项集闭包:</p>
<ul>
<li><figure>
<img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032026165.png" alt="image-20220103202629055" /><figcaption aria-hidden="true">image-20220103202629055</figcaption>
</figure></li>
<li><p>简单来说就是，对于I中的每一个项，如果<strong><span class="math inline">\(\cdot\)</span>点后面的第一个非终结符号</strong>，<strong>有对应的产生式</strong>在文法G中，且<strong>开头加点<span class="math inline">\(\cdot\)</span>的形式未收纳在I中</strong>，就<strong>加入</strong>；然后，<strong>重复</strong>此过程。<span class="math inline">\(\color{red}{Key}\)</span></p>
<p><span class="math inline">\(\color{blue}{例子}\)</span>： 一个SLR/LR(0)自动机</p>
<p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032128051.png" alt="image-20220103212857974" style="zoom:80%;" /></p></li>
</ul></li>
<li><p>定义GOTO函数：</p>
<ul>
<li><p>GOTO(<em>I,X</em>)定义: <em>I</em>中所有形如[<em>A →</em> <em>α·<strong>X</strong>β</em>]的项所对应的项[<em>A →</em> <em>α<strong>X</strong>·β</em>]的集合的闭包。</p>
<ul>
<li><p>简单来说就是，把点在X位置推进一个位置，重复闭包运算之后<strong>将得到的状态返回</strong>。<span class="math inline">\(\color{red}{Key}\)</span></p>
<p><span class="math inline">\(\color{blue}{继承上方例子}\)</span>:</p>
<p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032131430.png" alt="image-20220103213100365" style="zoom:80%;" /></p></li>
</ul></li>
</ul></li>
<li><p>LR(0)项集规范族的构造：</p>
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032033980.png" alt="image-20220103203317909" style="zoom:80%;" /></li>
<li>规范LR(0)项集族中的<strong>一个项集</strong>对应于<strong>LR(0)自动机中的一个状态</strong>。
<ul>
<li>也就是例子中的<span class="math inline">\(I_i\)</span></li>
</ul></li>
</ul></li>
<li><p>GOTO函数则<strong>定义了LR(0)自动机中的状态转换</strong>。GOTO(<em>I,X</em>)描述了当输入为<em>X</em>时离开状态<em>I</em>的转换。</p></li>
</ul></li>
<li><p>假设文法符号串γ使LR(0)自动机从开始状态0运行到某个状态<em>j</em>，LR(0)自动机按照如下方式决定移入或归约：</p>
<pre><code>  + 如果下一个输入符号为*a*，且*j*上有*a*的转换，就移入*a*
  + 否则就**对状态*j*中的项中点在最后的**产生进行归约(也就是说，状态*j*中的项会告诉我们使用那个产生式进行归约),规约会**退出原状态**,**回到上一个状态**。
  + &lt;img src=&quot;https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032039537.png&quot; alt=&quot;image-20220103203921446&quot; style=&quot;zoom:80%;&quot; /&gt; </code></pre>
<ul>
<li>以上图来说，移入id,转移到状态<span class="math inline">\(I_5\)</span>,<span class="math inline">\(I_5\)</span><strong>没有下一个输入<span class="math inline">\(*\)</span>的转移函数</strong>,而<span class="math inline">\(I_5\)</span>中<strong>有产生式</strong><span class="math inline">\(F\rightarrow id\cdot\)</span>,启示我们要<strong>按照该产生式规约</strong>，规约之后，相当于在<span class="math inline">\(I_0\)</span>状态移入<span class="math inline">\(F\)</span>,因此到达<span class="math inline">\(I_3\)</span>状态。之后，同理。</li>
</ul></li>
<li><p>LR语法分析表/SLR的语法分析表:</p>
<ul>
<li><p>包括<strong>ACTION和GOTO</strong>两个部分</p>
<ul>
<li><p>分为FOLLOW(S)的终结符号以及非终结符号两部分。</p></li>
<li><p>将LR(0)自动机的状态以及状态转移画成表的形式,画出上图例子的图之后即可。</p></li>
<li><p>因此，构造LR语法分析表/SLR的语法分析表与构造LR(0)自动机<strong>等价</strong>。</p></li>
<li><p>具体的构造算法:</p>
<ul>
<li><p>构造文法G的LR(0)项集规范族<em>C</em></p></li>
<li><figure>
<img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032100805.png" alt="image-20220103210052710" /><figcaption aria-hidden="true">image-20220103210052710</figcaption>
</figure></li>
<li><p><strong>简单来说</strong>，对于状态i中的<strong>位于<span class="math inline">\(\cdot\)</span>后的所有终结符号</strong>，将移入终结符号后<strong>抵达的状态</strong>移入表;对于<span class="math inline">\(\cdot\)</span>位于产生式A-&gt;..<strong>最后</strong>的情况，需要对<strong>FOLLOW(A)中的所有终结符号</strong>用<strong>该产生式</strong>进行规约;对于非终结符号，将GOTO(i,A)后的状态j填入。</p></li>
<li><p>规约的式子用<span class="math inline">\(r_i\)</span>表示。终结符号转移之后的状态用<span class="math inline">\(s_i\)</span>表示。</p>
<p><span class="math inline">\(\color{blue}{继承上方例子}\)</span>:</p>
<pre><code>  &lt;img src=&quot;https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032132601.png&quot; alt=&quot;image-20220103213250531&quot; style=&quot;zoom:80%;&quot; /&gt; </code></pre></li>
</ul></li>
<li><p>在分析过程中的<strong>中间分析状态</strong>，称为<strong>格局</strong>。</p></li>
<li><p>若<strong>SLR的语法分析表中</strong>各位置<strong>没有多个条目</strong>，则称为<strong>文法<em>G</em>的SLR(1)分析表</strong>。使用该分析表的分析器，称为<strong>G的SLR(1)语法分析器</strong>。G称为<strong>SLR(1)文法</strong> 。</p>
<ul>
<li>换句话说，没有二义性。</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="二义性文法的分析">二义性文法的分析</h4>
<ul>
<li>二义性文法都不是LR的,可以在LR分析器中实现消除二义性规则
<ul>
<li>基于优先级，**+时规约，*移入**</li>
<li>基于语义解释，i E t S,遇到else,<strong>要选择移入</strong>。</li>
</ul></li>
<li>二义性文法却有其存在的必要
<ul>
<li>二义性文法<strong>容易修改</strong>算符的<strong>优先级和结合性</strong>,<strong>简洁,高效</strong></li>
</ul></li>
</ul>
<h4 id="解题框架">解题框架</h4>
<ul>
<li>增广文法</li>
<li>LR(0)项集族</li>
<li>GOTO</li>
<li>FOLLOW</li>
<li>语法分析表</li>
<li>移进规约分析</li>
</ul>
<h3 id="chap.5">Chap.5</h3>
<h4 id="语义分析">语义分析</h4>
<ul>
<li>上下文无关文法无法解决语义分析的原因在于<span class="math inline">\(\color{red}{标示符在程序中先声明后使用}\)</span>等现象与上下文有关。</li>
</ul>
<h5 id="语法制导sdd">语法制导(SDD)</h5>
<ul>
<li><p>语法制导是在产生式的基础上<strong>附加语义规则</strong>，可以<strong>用于类型检查</strong>和<strong>中间代码</strong> 的翻译</p>
<ul>
<li>语音规则描述文法符号的<strong>属性值</strong>。</li>
<li><strong>上下文无关文法</strong>和<strong>属性及规则</strong>的结合</li>
<li><strong>属性和文法符号</strong>相关联</li>
<li><strong>语义规则和产生式</strong>相关联</li>
</ul></li>
<li><p>语法制导是<strong>上下文无关文法</strong>和<strong>属性及规则</strong>的结合。</p></li>
<li><p>属性包含了<strong>综合属性</strong>以及<strong>继承属性</strong>。</p>
<ul>
<li>区分，对于语法分析树
<ul>
<li><strong>综合属性</strong>是由<strong>结点本身</strong>以及<strong>子节点</strong>定义的。也就是<strong>从产生式的体传到头</strong>的属性。</li>
<li><strong>继承属性</strong>是由<strong>结点本身</strong>、<strong>父节点、左兄弟节点</strong>定义的。也就是<strong>从产生式的头传到体</strong>的属性。</li>
</ul></li>
</ul></li>
<li><p>给出翻译的<strong>抽象</strong>描述</p>
<p><strong>隐藏</strong>了语义动作的<strong>实现细节</strong></p>
<p>附在产生式上的语义规则<strong>没有明确告诉我们何时</strong>执行其中的语义动作</p></li>
</ul>
<h6 id="s属性的sdd">S属性的SDD</h6>
<ul>
<li><strong>只包含综合属性</strong>的SDD称为S属性的SDD 。</li>
</ul>
<h5 id="l属性的sdd">L属性的SDD</h5>
<ul>
<li>一个SDD称为L属性定义，对于一个产生式<em>A→X<strong>1</strong>X<strong>2</strong>…<strong>X</strong>n</em>所关联的语义规则<em>，</em>其中的每个属性：
<ul>
<li>要么是综合属性
<ul>
<li>因此<strong>S属性的SDD一定是L属性的SDD</strong></li>
</ul></li>
<li>要么<span class="math inline">\(X_i.a\)</span>这一个继承属性依赖于<span class="math inline">\(X_i\)</span>左边的非终结符号
<ul>
<li>(也就是<strong>左兄弟结点</strong>)</li>
</ul></li>
<li>依赖图没有环</li>
</ul></li>
<li>S属性的SDD 以及 L属性的SDD都<strong>一定有已知的属性求值顺序</strong>。</li>
<li>对于<strong>S属性</strong>的SDD,计算属性的过程只需要<strong>bottom-up、后根遍历</strong>(left,right,root)就可以了。</li>
<li>对于<strong>L属性</strong>的SDD,计算属性的过程只需要<strong>top-down、前根遍历</strong>(root,left,right)就可以了。在<strong>遍历一层</strong>的<strong>所有结点</strong>，计算<strong>继承属性</strong>，之后，计算<strong>当前结点的综合属性</strong>。
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041046430.png" alt="image-20220104104620264" style="zoom:80%;" /></li>
</ul></li>
</ul>
<h5 id="sdd中的副作用函数">SDD中的副作用（函数）</h5>
<ul>
<li>一个<strong>没有副作用</strong>（<strong>函数</strong>）的SDD有时候也称为<strong>属性文法</strong></li>
<li>翻译过程有时候需要副作用
<ul>
<li>打印结果(print)</li>
<li>符号表中加入标识符类型(addType)</li>
</ul></li>
</ul>
<h5 id="注释语法分析树">注释语法分析树</h5>
<ul>
<li><p>基于语法分析树，可以<strong>通过语义规则</strong>对语法分析树上的各个结点的<strong>所有属性进行求值</strong>。</p>
<p><strong>显示了它的各个属性的值</strong>的语法分析树称为<strong>注释语法分析树</strong> 。</p></li>
<li><p>对<strong>存在继承属性</strong>的语法分析树进行注释(属性求值)的时候，需要根据<strong>依赖图</strong>求解。</p>
<ul>
<li>并且继承属性与综合属性可能因为<strong>循环定义</strong>无法求解属性值。</li>
</ul></li>
</ul>
<h6 id="依赖图">依赖图</h6>
<ul>
<li><p>依赖图的<strong>结点</strong>为语法分析树每个节点的<strong>每个属性</strong></p></li>
<li><p>依赖图的<strong>边</strong>表示求值的依赖关系,具体的说就是<strong>值传递的关系</strong>，例如<span class="math inline">\(a=b\)</span>,那么b到a有一条<strong>有向边</strong>（指向a）,表示<strong>值从b传到a</strong>。</p>
<ul>
<li><p><span class="math inline">\(\color{green}{Example}\)</span>:</p>
<p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201032215977.png" alt="image-20220103221543906" style="zoom:80%;" /></p></li>
</ul></li>
<li><p>之后借助<strong>拓扑排序</strong>就可以解出属性求值顺序。</p>
<ul>
<li>拓扑排序的意思是对于有向边<span class="math inline">\(b-&gt;a\)</span>,那么排序的时候<strong>b排在a前面</strong>,因为<strong>b的值要传给a</strong>。</li>
<li><strong>存在环</strong>，则<strong>不存在拓扑排序</strong>,也就可以判断时候<strong>有循环定义</strong>。</li>
</ul></li>
</ul>
<h5 id="语法制导的翻译">语法制导的翻译</h5>
<ul>
<li><p>语法制导的翻译应用——抽象语法树：</p>
<ul>
<li><strong>抽象语法树</strong>是一种<strong>中间表示形式</strong>,树中每个结点代表一个程序构造，这个结点的子结点代表这个构造的有意义的组成部分。</li>
<li>借助抽象语法树可以较容易地完成到中间代码的翻译</li>
<li>各个结点用字段的记录对象来实现:
<ul>
<li>内部结点:构造函数<strong>Node(op, c1,c2,…ck)</strong>,op一般表示一种运算
<ul>
<li>创建新的结点或者属性</li>
</ul></li>
<li>叶子结点（<strong>最外层的结点</strong>）:构造函数<strong>Leaf(id, id.entry)</strong>
<ul>
<li>创建新的结点，并给这个结点一个属性id.entry</li>
</ul></li>
</ul></li>
<li>在<strong>自底向上分析过程</strong>中和<strong>归约动作一起进行求值</strong>。</li>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041101645.png" alt="image-20220104110108570" style="zoom:80%;" /></li>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201052030526.png" alt="image-20220105203028434" style="zoom:80%;" /></li>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041102112.png" alt="image-20220104110223040" style="zoom:80%;" /></li>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201052033953.png" alt="image-20220105203327879" style="zoom:80%;" /></li>
</ul></li>
<li><p>描述类型的结构，例如数组:</p>
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201052040370.png" alt="image-20220105204048294" style="zoom:80%;" />
<ul>
<li>C为数组类型，B为基本类型。<strong>C.b表示数组的每个元素的type,C.t表示数组的type</strong></li>
</ul></li>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041103047.png" alt="image-20220104110351968" style="zoom:80%;" /></li>
</ul></li>
</ul>
<h5 id="语法制导的翻译方案sdt">语法制导的翻译方案（SDT）</h5>
<ul>
<li><p>语法制导的翻译方案是指在产生式中<strong>附加动作</strong></p></li>
<li><p>产生式体中<strong>嵌入</strong>程序片段的<strong>上下文无关文法</strong></p></li>
<li><p>程序片段是<strong>语义动作</strong>，可以出现在体中的<strong>任何位置</strong></p></li>
<li><p>告诉我们<strong>何时</strong>执行相应的语义动作,翻译方案给出了更多的<strong>实现细节信息</strong></p></li>
<li><p>对<strong>S属性的SDD</strong>，可以构造一个SDT:</p>
<ul>
<li>每个动作都放在产生式的<strong>最后</strong></li>
<li>在利用这个产生式进行<strong>规约时执行这个动作</strong></li>
</ul>
<p>这样的SDT称为<strong>后缀翻译方案</strong></p></li>
<li><p>为了利用<strong>自顶向下技术</strong>进行<strong>语法分析</strong>，需要从SDT中<strong>消除左递归</strong></p>
<ul>
<li>对于执行print等副作用的动作，可以<strong>直接把动作当作终结符号</strong>处理。</li>
<li>当出现下图的类似综合属性的情况，就需要<strong>额外</strong>对非终结符号的<strong>属性进行改写</strong>。
<ul>
<li>框架不变，只不过加上了动作。</li>
</ul></li>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041206911.png" alt="image-20220104120626803" style="zoom:67%;" /></li>
</ul></li>
</ul>
<h3 id="chap.6">Chap.6</h3>
<h4 id="中间代码生成">中间代码生成</h4>
<ul>
<li>中间代码的表示形式有<strong>抽象语法树</strong>、<strong>三地址代码</strong>。
<ul>
<li><p>中间代码表示有利于进行<strong>高层次的优化</strong>（与<strong>源语言、目标机器</strong>无关）</p></li>
<li><p>并且为<strong>新的机器建编译器</strong>，<strong>只需要</strong>做从中间代码到新的目标代码的<strong>翻译器</strong>（<strong>前端独立</strong>）</p>
<p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201052118843.png" alt="image-20220105211800748" style="zoom:80%;" /></p></li>
<li><p><strong>静态类型检查</strong>和<strong>中间代码生成</strong>的过程都可以用<strong>语法制导的翻译(放在语义规则中完成)</strong>来描述和实现</p></li>
</ul></li>
</ul>
<h5 id="表达式的dag">表达式的DAG</h5>
<ul>
<li>在函数<strong>Leaf和Node</strong>每次被调用时，<strong>构造新节点前先检查</strong>是否已存在同样的节点，如果已经存在，则<strong>返回这个已有的节点</strong>
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041238783.png" alt="image-20220104123815715" style="zoom:67%;" /></li>
</ul></li>
</ul>
<h5 id="三地址代码">三地址代码</h5>
<ul>
<li><p>三地址代码是抽象语法树或DAG的线性表示形式</p></li>
<li><p>一条指令右侧<strong>最多有一个运算符</strong></p></li>
<li><p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041239083.png" alt="image-20220104123939019" style="zoom:67%;" /></p></li>
<li><p>三地址代码有以下指令形式，包括了<strong>各种条件转移指令、调用、返回</strong>等。每次<strong>只能用一个指令</strong>。</p>
<p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041244243.png" alt="image-20220104124403164" style="zoom:67%;" /></p></li>
<li><p>数组取项的时候，需要乘以8.</p>
<p>x[i]=y. i = 8*index</p></li>
</ul>
<h5 id="类型">类型</h5>
<ul>
<li><p>类型检查。比如检查&amp;&amp;左右都是boolean类型。</p></li>
<li><p>声明的文法：</p>
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041403079.png" title="fig:" alt="image-20220104140313021" /></li>
</ul></li>
<li><p>即声明一个<strong>基本类型、数组类型</strong>或者<strong>记录</strong></p></li>
<li><p>对于特别的数组类型，array(num,type)也是一个类型表达式。</p></li>
<li><p>用类型表达式进行类型声明，除了<strong>类型声明</strong>之外，还要进行<strong>类型的存储布局</strong>。</p>
<ul>
<li>约定<strong>字节</strong>是可寻址的<strong>最小内存单位</strong></li>
<li>一个字节通常是一个<strong>8个二进制位</strong></li>
<li><strong>类型的宽度</strong>表示<strong>一个对象所需的存储单元的数量</strong>
<ul>
<li>一个整型数的宽度是4个字节。一个浮点数的宽度是8个字节。</li>
<li>注意通常内存都会进行<strong>对齐</strong>。</li>
<li>计算类型以及宽度的SDT:
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041404200.png" alt="image-20220104140433130" style="zoom:67%;" />
<ul>
<li>当推导没有进行到C-&gt;<span class="math inline">\(\epsilon\)</span>的时候，<strong>默认T的宽度类型按照C</strong>来。</li>
<li>因此，需要额外记录<strong>基本类型B的宽度以及类型</strong>。</li>
</ul></li>
<li>例子为下方对int[2][3]的翻译过程
<ul>
<li>要注意的就是<span class="math inline">\(\color{red}{T-&gt;B C,C-&gt;\epsilon}\)</span>的额外动作</li>
</ul></li>
</ul></li>
</ul></li>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201052119444.png" alt="image-20220105211922374" style="zoom:80%;" /></li>
</ul></li>
</ul>
<h5 id="表达式翻译为三地址代码">表达式翻译为三地址代码</h5>
<ul>
<li><p><strong>表达式翻译为三地址代码</strong>的SDD:</p>
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041421909.png" alt="image-20220104142135827" style="zoom:80%;" /></li>
<li>addr属性表示值的地址，code表示三地址代码
<ul>
<li>addr需要在注释语法分析树中画出。</li>
</ul></li>
</ul></li>
<li><p>数组类型的语法制导翻译:</p>
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041318730.png" alt="image-20220104131845623" style="zoom:80%;" /></li>
</ul></li>
<li><p>数组元素的寻址:</p>
<ul>
<li>数组a[i1][i2]...[ik]的第一个元素的<strong>相对位置</strong>记为base,之后按照<em>base+i<strong>1</strong></em>w<strong>1</strong>+i<strong>2</strong><em>w<strong>2</strong>+…+<strong>i</strong>k</em><strong>w</strong>k计算地址。上述地址的计算是<strong>按行存放</strong>的。
<ul>
<li>无论是按列存放还是按照行存放，表示都不会变，a[i][j]仍然是a[i][j]
<ul>
<li><strong>列存放的次序</strong>: a[i][j]-&gt;a[i+1][j], 无论是几维，都<strong>从高开始堆</strong></li>
<li><strong>行存放的次序</strong>: a[i][j]-&gt;a[i][j+1], 无论是几维，都<strong>从低开始堆</strong></li>
</ul></li>
</ul></li>
</ul></li>
<li><p><strong>数组引用</strong>生成代码的<strong>翻译方案</strong>：</p>
<ul>
<li><p>非终结符号L的三个综合属性</p>
<p>L.addr指示一个临时变量。计算<strong>数组引用的偏移量</strong></p>
<p>L.array是一个<strong>指向数组名字对应的符号表条目的指针</strong>。L.array.base为该数组的基地址。</p>
<p>L.type是<strong>L生成的子数组的类型</strong>。对于任何数组类型t，其宽度由t.width给出。t.elem给出其数组元素的类型。</p></li>
<li><p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201052135266.png" alt="image-20220105213525186" style="zoom:80%;" /></p></li>
</ul></li>
<li><p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041335914.png" alt="image-20220104133535820" style="zoom:80%;" /></p></li>
</ul>
<h5 id="记录与字段">记录与字段</h5>
<ul>
<li>一个记录中各字段名称需要不同，但是不同记录可以相同。</li>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041418346.png" alt="image-20220104141847287" style="zoom:80%;" /></li>
<li>记录本身处于原始符号表。Env.push(top)</li>
<li>每个记录都会使用一个新的符号表 。 top = new Env()</li>
<li>在新环境中，每个字段声明重新从0开始算。</li>
</ul>
<h5 id="控制流语句的翻译">控制流语句的翻译</h5>
<ul>
<li><p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041343123.png" alt="image-20220104134300976" style="zoom:80%;" /></p></li>
<li><figure>
<img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041345828.png" alt="image-20220104134506763" /><figcaption aria-hidden="true">image-20220104134506763</figcaption>
</figure></li>
<li><figure>
<img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041345148.png" alt="image-20220104134552075" /><figcaption aria-hidden="true">image-20220104134552075</figcaption>
</figure>
<ul>
<li>一开始，我们<strong>只有S.code以及S.next两个属性值</strong>，因此跳转<strong>除非是跳到S.next</strong>,<strong>不然都要生成label</strong>。</li>
</ul></li>
</ul>
<h5 id="避免冗杂的goto语句">避免冗杂的goto语句</h5>
<ul>
<li><p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041346087.png" alt="image-20220104134658011" style="zoom:80%;" /></p>
<p>goto L3是冗杂的。</p>
<p>可以通过用ifFalse等价替换if，来避免不必要的goto语句</p></li>
<li><p>同时在SDD中引入一个<strong>特殊标号“fall”</strong>(穿越，fall through)，表示<strong>不要生成任何跳转指令</strong>,<strong>直接顺序执行下一条语句</strong>。</p></li>
<li><p>注意<strong>部分fall的时候还要生成一个newlabel</strong>，指向跳转的位置才行。</p></li>
</ul>
<h5 id="回填colorblue上课略过">回填(<span class="math inline">\(\color{blue}{上课略过}\)</span>)</h5>
<ul>
<li>除了使用S.next这一个<strong>继承属性描述跳转位置</strong>之外，利用<strong>回填</strong>的技术只进行<strong>一趟</strong>处理。
<ul>
<li>生成跳转指令时<strong>暂时不指定该跳转指令的目标</strong>。等到<strong>能够确定正确的目标标号</strong>时<strong>再去填充</strong>这些指令的目标位置。</li>
<li>需要回填的指令将被<strong>放在一个列表</strong>中</li>
</ul></li>
</ul>
<h3 id="chap.7">Chap.7</h3>
<h4 id="运行时刻的环境">运行时刻的环境</h4>
<ul>
<li>产生目标代码后，将于操作系统协作，在<strong>目标机器上执行代码</strong>,由<strong>编译器创建</strong>并管理<strong>运行时刻环境</strong></li>
<li>编译系统给程序里的对象<strong>分配空间</strong>，包括代码，静态和动态数据，全局和局部数据等</li>
</ul>
<h5 id="存储管理">存储管理</h5>
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041436672.png" alt="image-20220104143643611" style="zoom:67%;" />
<ul>
<li>代码区主要用于<strong>放置可执行目标代码</strong>，在<strong>编译时刻</strong>就可以<strong>确定大小</strong>，通常<strong>在存储的低地址端</strong>。</li>
<li>静态区存放<strong>全局常量</strong>和<strong>编译器产生</strong>的某些数据</li>
<li>剩余的动态区域由<strong>堆区、栈区</strong>分配，位于<strong>在剩余地址空间的两端</strong>。
<ul>
<li><strong>堆区、栈区</strong>的生长方向相反。</li>
<li><strong>动态区</strong>的数据大小<strong>在运行时刻才能决定</strong>。</li>
<li>栈区主要跟与函数调用相关：
<ul>
<li>当一个<strong>函数被调用</strong>的时候，用于<strong>存放该函数的局部变量</strong>的空间被<strong>压入栈</strong>。</li>
<li>当这个函数<strong>结束</strong>时，该空间<strong>从栈中弹出</strong></li>
<li>栈区空间<strong>可以</strong>被多个<strong>活动阶段不重叠的函数共享</strong></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h5 id="函数调用">函数调用</h5>
<ul>
<li><p>函数体的一次<strong>执行</strong>称为该函数的一个<strong>活动</strong>（Activation）</p></li>
<li><p>从函数体执行的第一步到最后一步的步序列为该函数的<strong>活动生存期</strong>。</p></li>
<li><p>函数活动的<strong>嵌套特性</strong>：即一个函数p的一个活动调用了函数q，那么q的该次活动必定在p的活动结束之前结束。</p></li>
<li><p>可以用<strong>活动树</strong>来说明在整个程序运行期间的所有函数的活动。</p>
<ul>
<li><strong>根节点是main函数</strong>的活动。在<strong>表示函数p</strong>的某个活动的节点上，其<strong>子节点</strong>对应于<strong>被p的这次活动调用的各个函数</strong>的活动。我们<strong>按照这些活动被调用的顺序</strong>，<strong>自左向右地</strong>表示它们。</li>
<li>一个<strong>子节点</strong>必须<strong>在其右兄弟节点的活动开始之前结束</strong></li>
<li>因此，<strong>函数调用</strong>序列和<strong>活动树的先序遍历</strong>相对应</li>
<li><strong>函数返回</strong>序列和<strong>活动树的后序遍历</strong>相对应</li>
<li><strong>先进后出</strong>适合栈存储</li>
</ul></li>
<li><p>每个活动都有一个<strong>活动记录</strong>：</p>
<ul>
<li><p>活动树的<strong>根位于栈底</strong>，<strong>栈中全部活动记录的序列</strong>对应于在活动树中<strong>从根节点到达当前活跃的活动节点的路径</strong>。<strong>当前程序控制所在活动的活动</strong>记录位于<strong>栈顶</strong></p></li>
<li><p>存储<strong>所有</strong>的<strong>尚未返回</strong>的函数调用信息</p></li>
<li><p><strong>活动记录</strong>记录了下图中的数据：</p>
<p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041540688.png" alt="image-20220104154040579" style="zoom:67%;" /></p>
<ul>
<li>访问链描述的是 <strong>函数在哪个父函数体中定义</strong>，那么父函数就会给一个访问链给子函数。(作业涉及)</li>
</ul></li>
</ul></li>
</ul>
<h5 id="调用代码序列返回代码序列">调用代码序列、返回代码序列</h5>
<ul>
<li><strong>实现函数调用</strong>的代码称为<strong>调用代码序列</strong>
<ul>
<li>为一个活动记录<strong>在栈中分配空间</strong>，并在此记录的<strong>字段中填写信息</strong></li>
<li>调用代码序列分为<strong>调用者</strong>和<strong>被调用者</strong>的代码</li>
<li>调用者和被调用者之间传递的值（包括<strong>参数和返回值</strong>），一般被放在<strong>被调用者活动记录</strong>的<strong>开始位置</strong></li>
<li><strong>固定长度的</strong>项（包括控制链、访问链和机器状态字段）放在记录的<strong>中间</strong>位置</li>
<li>开<strong>始不知道大小的</strong>项（例如动态数组）被放置在活动记录的<strong>尾部</strong>
<ul>
<li>放在尾部才能<strong>随时增长</strong>空间。</li>
</ul></li>
</ul></li>
<li><strong>返回代码序列</strong>是<strong>恢复机器状态</strong>，使得调用函数能够在调用结束后继续执行的代码。
<ul>
<li><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041545284.png" alt="image-20220104154529204" style="zoom:80%;" /></li>
<li>调用者<strong>计算实参</strong>的值</li>
<li>调用者将<strong>返回地址和top_sp</strong>的值放在被调用者的活动记录中，然后<strong>增加top_sp</strong>的值</li>
<li>被调用者<strong>保存寄存器值和其它状态信息</strong>,将<strong>返回值</strong>放在与参数相邻的位置,<strong>恢复top_sp和其它寄存器</strong>，然后跳转到由调用者放在机器状态字段中的<strong>返回地址</strong></li>
</ul></li>
</ul>
<h5 id="堆区管理">堆区管理</h5>
<ul>
<li><p>堆用来存储那些<strong>生命周期不确定</strong>，由<strong>程序显式删除来结束生存期</strong>的数据对象。它们的<strong>生存期与函数无关</strong>。</p></li>
<li><p>用<strong>存储管理器</strong>来<strong>分配和回收堆区空间</strong></p>
<ul>
<li><p>最好<strong>尽量减少存储碎片</strong>、<strong>充分利用存储子系统</strong>、<strong>减少分配和回收的时间</strong>。</p></li>
<li><p>计算机的存储结构一般分为<strong>寄存器，一级缓存，二级缓存，物理内存，虚拟内存</strong>。速度依次<strong>降低</strong>。</p></li>
<li><p>为了<strong>充分利用存储空间、不浪费时间</strong>，需要考虑程序的<strong>时间局部性</strong>以及<strong>空间局部性</strong>。</p></li>
<li><p>为了尽量减少存储碎片，如果进行<strong>人工垃圾回收</strong>，可能会发生：</p>
<ul>
<li><strong>内存泄漏</strong>：<strong>一直未能删除</strong>不会被引用的数据</li>
<li><strong>悬空指针引用</strong>：<strong>引用已经被删除</strong>的数据</li>
</ul>
<p>最好就是进行<strong>垃圾回收算法的研究</strong>。基本思想：<strong>可达性分析</strong>。分析一个存储<strong>是否可以被引用或到达</strong>。</p>
<ul>
<li>定义根集为<strong>不需要任何指针操作</strong>就可以<strong>被程序直接访问</strong>的数据。</li>
<li>用<strong>引用计数法</strong>表示可达性：
<ul>
<li>对象分配:<strong>新对象</strong>的引用计数被设置为<strong>1</strong></li>
<li>参数传递:<strong>被传递</strong>给一个函数的<strong>每个对象的引用计数加1</strong></li>
<li>引用赋值:若u和v都是引用，对于语句u=v, <strong>v指向的对象</strong>的引用计数<strong>加1</strong>，u<strong>原来指向的原对象</strong>引用计数<strong>减1</strong></li>
<li>函数返回:该函数<strong>活动记录的局部变量</strong>中所指向的对象的<strong>引用减1</strong>.</li>
<li>可达性传递丢失:当一个对象的<strong>引用计数变成0</strong>时，我们必须将<strong>该对象中的各个引用所指向的每个对象</strong>的引用计数<strong>减1</strong> ,然后准备删除它。</li>
</ul></li>
<li>对于环结构，该方法没法进行<strong>垃圾回收</strong>。
<ul>
<li>引用计数<strong>永远大于0</strong>。</li>
</ul></li>
<li>基于跟踪的垃圾回收:
<ul>
<li><strong>基本的标记清扫式回收器</strong>:
<ul>
<li>找出所有可达对象,<strong>将其他对象删除</strong>
<ul>
<li>只作清扫。</li>
</ul></li>
</ul></li>
<li><strong>标记压缩回收器</strong>
<ul>
<li>找出所有可达对象,在堆区内移动可达对象以<strong>消除存储碎片</strong>
<ul>
<li>也就是“<strong>压缩</strong>”的含义。</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="chap.8">Chap.8</h3>
<h4 id="代码生成">代码生成</h4>
<ul>
<li><p>根据<strong>中间表示</strong>生成<strong>目标机器代码</strong>,代码生成器之前<strong>可能有一个优化组件</strong></p></li>
<li><p>代码生成器的任务是<strong>指令选择</strong>、<strong>寄存器分配和指派</strong>、<strong>指令排序</strong>（安排指令的顺序）。</p></li>
<li><p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041629046.png" alt="image-20220104162903970" style="zoom:67%;" /></p>
<ul>
<li>LD<strong>只能加载到寄存器</strong>，ST<strong>装载到指定内存位置</strong>。
<ul>
<li>*p=9等修改指定内存位置数据的，需要使用ST指令。LD只会修改寄存器的值</li>
<li>return 之后的代码不执行噢</li>
</ul></li>
</ul>
<p><img src="https://gitee.com/DespairL/typora-drawing-bed/raw/master/202201041641943.png" alt="image-20220104164148872" style="zoom:80%;" /></p>
<ul>
<li>call的过程就是把<strong>返回地址#..用 ST 指令放到指定位置处</strong>,<strong>可以</strong>存放在代码段的<strong>后段</strong>，用*<strong>label</strong>取出即可。
<ul>
<li>用BR指令跳转到被调用函数处执行。</li>
</ul></li>
</ul></li>
<li><p>指令的寻址方式:</p>
<ul>
<li>a(r)寻址:a的左值<strong>加</strong>上存放在<strong>寄存器r</strong>中的值,
<ul>
<li>这里注意括号里<strong>必须是寄存器</strong>噢</li>
</ul></li>
<li><strong>contents(x)</strong>表示x所代表的<strong>寄存器或内存中存放的值</strong>
<ul>
<li>a(r)翻译为contents(a+contents(r))</li>
</ul></li>
<li><strong>constant(r)</strong>，寄存器r中的值<strong>加上前面的常数</strong></li>
<li>*<strong>r</strong>表示r的内容所表示的位置上存放的位置中的值,即<strong>contents(r)</strong></li>
<li>在<strong>常数</strong>前面加上#</li>
</ul></li>
<li><p>过程调用相关的栈式分配:</p>
<ul>
<li>在<strong>寄存器SP</strong>中存放一个<strong>指向栈顶</strong>的活动记录的开始处的<strong>指针</strong>。</li>
<li>发生<strong>过程调用</strong>时，调用过程<strong>增加SP值</strong>，并把<strong>控制转移</strong>至被调用过程。返回时，<strong>减少SP的值</strong>，从而<strong>释放被调用过程的活动记录</strong>。</li>
</ul></li>
</ul>
<h5 id="基本块与流图">基本块与流图</h5>
<ul>
<li><p>把中间代码划为基本块。</p>
<ul>
<li><p>控制流<strong>只能从基本块中的第一个指令进入该块</strong>。没有跳转到基本块中间的转移指令。</p>
<p>除了基本块的最后一个指令，控制流<strong>在离开基本块之前不会停止或者跳转</strong>。</p></li>
<li><p>确定基本块：</p>
<ul>
<li>确定基本块的<strong>首指令</strong>：
<ul>
<li>中间代码的<strong>第一个三地址指令</strong>是一个首指令</li>
<li>任意一个条件或无条件转移指令的<strong>目标指令</strong>是一个首指令</li>
<li>紧跟在一个<strong>条件或无条件转移指令之后的指令</strong>是一个首指令</li>
</ul></li>
<li>每个首指令对应的基本块包括了<strong>从它自己开始，直到下一个首指令</strong>（不含）或者<strong>结尾指令之间的所有指令</strong>。</li>
</ul></li>
</ul></li>
<li><p>流图的结点是基本块：</p>
<ul>
<li>从基本块B到基本块C之间有一条边当且仅当基本块C的第一个指令可能紧跟在B的最后一条指令之后执行。
<ul>
<li><strong>有一个从B的结尾跳转到C的开头</strong>的条件或无条件<strong>跳转语句</strong></li>
<li>按照原来的三地址语句序列中的顺序，C紧跟在B之后，且B的结尾不存在跳转语句。</li>
<li>增加一个入口和出口。入口到流图的第一个基本块有一条边。从任何可能是程序的最后执行指令的基本块到出口有一条边。</li>
</ul></li>
<li>流图可以识别循环：
<ul>
<li>若满足以下条件，则流图中的一个结点集合L是一个循环：
<ul>
<li>从<strong>整个流图的入口结点</strong>开始到<strong>L中的任何结点的路径</strong>都<strong>必然经过循环入口</strong>结点。</li>
<li>L的<strong>每个结点</strong>都有一个<strong>到达L的入口结点的非空路径</strong>，并且该路径都在L中。</li>
</ul></li>
</ul></li>
</ul></li>
<li><p><strong>基本块的优化</strong>又称为局部优化</p>
<ul>
<li>基本块可以用DAG来表示
<ul>
<li><strong>消除局部公共子表达式</strong></li>
<li><strong>消除死代码</strong>
<ul>
<li><strong>删除没有附加活跃变量</strong>且<strong>没有父节点</strong>的结点</li>
</ul></li>
<li><strong>语句重排</strong>序</li>
<li>对运算分量进行符合代数规则重排序
<ul>
<li>用代数恒等式简化运算，减小计算开销,除法-&gt;乘法，乘法-&gt;加法</li>
</ul></li>
</ul></li>
<li>数组引用的DAG表示：
<ul>
<li>x=a[i]，用运算符为=[]的结点表示。这个结点的<strong>左右子节点</strong>是数组初始值a0和下标i。变量x是这个结点的<strong>标号</strong>之一。</li>
<li>a[j]=y, 这个结点的<strong>三个子节点</strong>分别表示a0、j和y。<strong>没有其它变量用这个结点标号</strong>。此结点创建后，当前已经建立的、<strong>其值依赖于的a0所有结点被杀死</strong>。</li>
</ul></li>
</ul></li>
<li><p>寄存器的使用约定:</p>
<ul>
<li><strong>各个运算分量必须存放在寄存器</strong>中</li>
<li>寄存器适合存放<strong>临时变量</strong></li>
<li>寄存器用来存放在一个基本块中计算而在<strong>另一个基本块中使用</strong>的值。</li>
<li>寄存器用来<strong>帮助</strong>进行运行时刻<strong>存储管理</strong>。如运行时刻栈的指针。</li>
</ul></li>
<li><p><strong>寄存器描述符</strong>：<strong>记录寄存器当前存放</strong>了哪个变量的值。</p></li>
<li><p><strong>地址描述符</strong>：<strong>记录每个名字的当前值的存放处所</strong>，可以是寄存器，也可以是内存地址，或者它们的集合</p></li>
<li><p><strong>LD，ST指令、赋值</strong>等会修改这些描述符。</p></li>
<li><p><strong>代码生成算法</strong>:</p>
<ul>
<li>调用<strong>getreg(i)选择寄存器</strong>
<ul>
<li>i值已经存放到某寄存器x，就选x</li>
<li>未存放，有空寄存器y,就选y</li>
<li>没有空寄存器y,复用代价最小的寄存器</li>
</ul></li>
<li>根据寄存器<strong>有无加载</strong>，<strong>生成LD指令</strong></li>
<li><strong>修改寄存器描述符</strong>，修正存放对象的描述</li>
</ul></li>
</ul>
<h3 id="chap.9">Chap.9</h3>
<h4 id="机器无关的优化"><strong>机器无关的优化</strong></h4>
<ul>
<li>代码优化
<ul>
<li>在目标代码中<strong>消除不必要的指令</strong></li>
<li>把一个指令序列替换为一个<strong>完成相同功能的更快的</strong>指令序列</li>
</ul></li>
<li>可做的优化
<ul>
<li>可以消去<strong>流图</strong>中的<strong>全局公共子表达式</strong></li>
<li>复制传播:
<ul>
<li>复制传播转换的基本思想是在<strong>复制语句u=v之后</strong>尽可能的<strong>用v来替代u</strong>。</li>
</ul></li>
<li>死代码的消除:
<ul>
<li>一个变量在一个程序点上的值在以后不再被使用，则变成不活跃了，变成死代码了。</li>
</ul></li>
<li>代码移动:
<ul>
<li>在进入循环前，<strong>对循环不变表达式(循环中值不变的表达式)进行求值</strong>。</li>
<li>尽可能减少内部循环的指令可能</li>
</ul></li>
<li>归纳变量：
<ul>
<li>对于一个变量x，如果<strong>存在一个正的或负的常数c</strong>使得每次x被赋值时<strong>它的值总是增加c</strong>，那么<strong>x被称为归纳变量</strong></li>
<li>如果<strong>有一组归纳变量的值的变化保持步调一致</strong>，常常可以<strong>将这组变量删除只剩一个</strong>。</li>
<li>基本可以认为<strong>循环的迭代变量</strong>就是归纳变量。
<ul>
<li>把随着i、j变化的变量尽可能去掉i、j</li>
</ul></li>
</ul></li>
<li>强度削减：</li>
<li>把一个<strong>高代价的运算</strong>（比如乘法）替换为一个<strong>代价较低的运算</strong>（比如加法）的转换称为强度削减。</li>
</ul></li>
<li>代码生成的过程:
<ul>
<li>生成三地址代码</li>
<li>找出基本块</li>
<li>流图</li>
<li>删除全局公共子表达式</li>
<li>复制传播、死代码的消除、强度削减、删除归纳变量</li>
</ul></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Note/" rel="tag"><i class="fa fa-tag"></i> Note</a>
              <a href="/tags/CS/" rel="tag"><i class="fa fa-tag"></i> CS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/02/NoteforNN/" rel="prev" title="神经网络笔记">
      <i class="fa fa-chevron-left"></i> 神经网络笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/27/LeetCode/" rel="next" title="LeetCode">
      LeetCode <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#chap.1"><span class="nav-number">1.</span> <span class="nav-text">Chap.1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">编译器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chap.3"><span class="nav-number">2.</span> <span class="nav-text">Chap.3</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E4%BD%9C%E7%94%A8"><span class="nav-number">2.1.</span> <span class="nav-text">词法分析器作用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%8D%E6%B3%95%E5%8D%95%E5%85%83%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.1.</span> <span class="nav-text">词法单元及相关概念</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre"><span class="nav-number">2.2.</span> <span class="nav-text">正则表达式(RE)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%8D%E6%B3%95%E5%8D%95%E5%85%83%E7%9A%84%E8%AF%86%E5%88%AB"><span class="nav-number">2.3.</span> <span class="nav-text">词法单元的识别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA-fa"><span class="nav-number">2.4.</span> <span class="nav-text">有穷自动机 FA</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chap.4"><span class="nav-number">3.</span> <span class="nav-text">Chap.4</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8"><span class="nav-number">3.1.</span> <span class="nav-text">语法分析器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E6%B3%95"><span class="nav-number">3.1.1.</span> <span class="nav-text">文法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8E%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%9B%B8%E6%AF%94"><span class="nav-number">3.1.2.</span> <span class="nav-text">与词法分析相比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E4%B9%8B%E5%89%8D"><span class="nav-number">3.1.3.</span> <span class="nav-text">在语法分析之前</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E6%9E%90"><span class="nav-number">3.2.</span> <span class="nav-text">自顶向下分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ll1%E6%96%87%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">LL(1)文法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%88%86%E6%9E%90"><span class="nav-number">3.4.</span> <span class="nav-text">自底向上分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A7%BB%E8%BF%9B%E5%BD%92%E7%BA%A6%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6"><span class="nav-number">3.4.1.</span> <span class="nav-text">移进归约语法分析框架</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E4%B9%89%E6%80%A7%E6%96%87%E6%B3%95%E7%9A%84%E5%88%86%E6%9E%90"><span class="nav-number">3.5.</span> <span class="nav-text">二义性文法的分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6"><span class="nav-number">3.6.</span> <span class="nav-text">解题框架</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chap.5"><span class="nav-number">4.</span> <span class="nav-text">Chap.5</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="nav-number">4.1.</span> <span class="nav-text">语义分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BCsdd"><span class="nav-number">4.1.1.</span> <span class="nav-text">语法制导(SDD)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#s%E5%B1%9E%E6%80%A7%E7%9A%84sdd"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">S属性的SDD</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#l%E5%B1%9E%E6%80%A7%E7%9A%84sdd"><span class="nav-number">4.1.2.</span> <span class="nav-text">L属性的SDD</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sdd%E4%B8%AD%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.3.</span> <span class="nav-text">SDD中的副作用（函数）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91"><span class="nav-number">4.1.4.</span> <span class="nav-text">注释语法分析树</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%9B%BE"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">依赖图</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91"><span class="nav-number">4.1.5.</span> <span class="nav-text">语法制导的翻译</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91%E6%96%B9%E6%A1%88sdt"><span class="nav-number">4.1.6.</span> <span class="nav-text">语法制导的翻译方案（SDT）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chap.6"><span class="nav-number">5.</span> <span class="nav-text">Chap.6</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="nav-number">5.1.</span> <span class="nav-text">中间代码生成</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84dag"><span class="nav-number">5.1.1.</span> <span class="nav-text">表达式的DAG</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E5%9C%B0%E5%9D%80%E4%BB%A3%E7%A0%81"><span class="nav-number">5.1.2.</span> <span class="nav-text">三地址代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.3.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BF%BB%E8%AF%91%E4%B8%BA%E4%B8%89%E5%9C%B0%E5%9D%80%E4%BB%A3%E7%A0%81"><span class="nav-number">5.1.4.</span> <span class="nav-text">表达式翻译为三地址代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E4%B8%8E%E5%AD%97%E6%AE%B5"><span class="nav-number">5.1.5.</span> <span class="nav-text">记录与字段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%BF%BB%E8%AF%91"><span class="nav-number">5.1.6.</span> <span class="nav-text">控制流语句的翻译</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%86%97%E6%9D%82%E7%9A%84goto%E8%AF%AD%E5%8F%A5"><span class="nav-number">5.1.7.</span> <span class="nav-text">避免冗杂的goto语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9E%E5%A1%ABcolorblue%E4%B8%8A%E8%AF%BE%E7%95%A5%E8%BF%87"><span class="nav-number">5.1.8.</span> <span class="nav-text">回填(\(\color{blue}{上课略过}\))</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chap.7"><span class="nav-number">6.</span> <span class="nav-text">Chap.7</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%9A%84%E7%8E%AF%E5%A2%83"><span class="nav-number">6.1.</span> <span class="nav-text">运行时刻的环境</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">6.1.1.</span> <span class="nav-text">存储管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">6.1.2.</span> <span class="nav-text">函数调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E4%BB%A3%E7%A0%81%E5%BA%8F%E5%88%97%E8%BF%94%E5%9B%9E%E4%BB%A3%E7%A0%81%E5%BA%8F%E5%88%97"><span class="nav-number">6.1.3.</span> <span class="nav-text">调用代码序列、返回代码序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="nav-number">6.1.4.</span> <span class="nav-text">堆区管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chap.8"><span class="nav-number">7.</span> <span class="nav-text">Chap.8</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="nav-number">7.1.</span> <span class="nav-text">代码生成</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%9D%97%E4%B8%8E%E6%B5%81%E5%9B%BE"><span class="nav-number">7.1.1.</span> <span class="nav-text">基本块与流图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chap.9"><span class="nav-number">8.</span> <span class="nav-text">Chap.9</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E6%97%A0%E5%85%B3%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">8.1.</span> <span class="nav-text">机器无关的优化</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yanquan Chen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Yanquan Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/DespairL" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;DespairL" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Chen61723827" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Chen61723827" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yanquan Chen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
