<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"despairl.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="YQBlog | HaveFun!">
<meta property="og:url" content="https://despairl.github.io/index.html">
<meta property="og:site_name" content="YQBlog | HaveFun!">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yanquan Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://despairl.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>YQBlog | HaveFun!</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">YQBlog | HaveFun!</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://despairl.github.io/2022/04/11/%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yanquan Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQBlog | HaveFun!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/11/%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA%E5%99%A8/" class="post-title-link" itemprop="url">Boltzman 玻尔兹曼机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-11 14:37:07 / Modified: 21:21:07" itemprop="dateCreated datePublished" datetime="2022-04-11T14:37:07+08:00">2022-04-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ML-Note/" itemprop="url" rel="index"><span itemprop="name">ML Note</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="boltzman">Boltzman</h3>
<p>神经网络中有一类模型为网络定义了一个energy,当energy最小化时网络达到理想状态。网络训练就是为了最小化energy。</p>
<p>Boltzman机的结构分为两层：</p>
<ul>
<li>visible layer : 表征了数据的input/output</li>
<li>hidden layer : 表示了数据的内在分布，intrinsic information</li>
</ul>
<p>其神经元都是Boolean，1表示active,0表示negtive。</p>
<p>Boltzman机将每个样本都看成是一个状态向量<span class="math inline">\(s\)</span>,在训练过程中，使得其出现的概率尽可能大。</p>
<p>用向量<span class="math inline">\(s\in \{0,1\}^n\)</span>表示<span class="math inline">\(n\)</span>个神经元的状态，<span class="math inline">\(w_{ij}\)</span>表示神经元<span class="math inline">\(i,j\)</span>之间的连接权重,<span class="math inline">\(\theta_i\)</span>表示神经元<span class="math inline">\(i\)</span>的阈值，Boltzman机对于状态向量<span class="math inline">\(s\)</span>定义energy如下: <span class="math display">\[
E(s) = - \sum_{i=1}^{n-1} \sum_{j=i+1}^{n} w_{ij} s_i s_j - \sum_{i=1}^{n} \theta_i s_i
\]</span> 如果网络以不依赖于input的顺序进行update，那么网络最终会趋于Boltzmann分布（平稳分布）。此时状态向量<span class="math inline">\(s\)</span>出现的概率仅由其energy与其他所有可能状态的energy确定。 <span class="math display">\[
P(s) = \frac{e^{-E(s)}}{\sum_t e^{-E(t)}} 
\]</span> 标准的Boltzman机是一个全连接图，复杂度太高，难以解决实际问题，常用的是受限Boltzman机(<strong>Restricted Boltzman Machine, RBM</strong>)。RBM只保留了visible layer、hidden layer之间的connection，与标准Boltzman机对比如下：</p>
<div data-align="center">
<pre><code>&lt;a&gt;
    &lt;img src=&quot;https://admirelotusimagebed.oss-cn-hangzhou.aliyuncs.com/images/image-20220411153318496.png&quot; style=&quot;zoom: 50%;&quot;&gt;  
&lt;/a&gt;</code></pre>
</div>
<p>RBM常常是用"对比散度"(<strong>Contrastive Divergence，CD</strong>)进行训练。</p>
<p>一般是<strong>k步CD</strong>算法，而这些细节西瓜书是没有的。。。</p>
<p>其步骤为:</p>
<ul>
<li><p>对每个visible layer的样本<span class="math inline">\(\mathbf{v}\)</span>,根据 <span class="math display">\[
  P(\mathbf{h} | \mathbf{v}) = \prod_{j=1}^q P(h_j|\mathbf{v})
  \]</span> 计算hidden layer的概率分布，然后根据这个概率分布采样得到<span class="math inline">\(\mathbf{h}\)</span>。</p></li>
<li><p>执行k次Gibbs采样，其中每一次都先后执行:</p>
<ul>
<li><p>根据 <span class="math display">\[
  P(\mathbf{v} | \mathbf{h}) = \prod_{i=1}^d P(v_i|\mathbf{h})
  \]</span> 计算概率分布，然后根据这个概率分布采样得到<span class="math inline">\(\mathbf{v}^\prime\)</span>。</p></li>
<li><p>类似的得到<span class="math inline">\(\mathbf{h}^{\prime}\)</span></p></li>
</ul></li>
<li><p>接着利用k步Gibbs采样之后得到的<span class="math inline">\(\mathbf{v}^{k},\mathbf{h}^{k}\)</span>来近似估计</p></li>
<li><p>更新连接权重<span class="math inline">\(w\)</span> : <span class="math display">\[
  \Delta w = \eta (\mathbf{v} \mathbf{h}^T - \mathbf{v^k}\mathbf{h^k}^T )
  \]</span></p>
<div data-align="center">
<pre><code>  &lt;a&gt;
      &lt;img src=&quot;https://admirelotusimagebed.oss-cn-hangzhou.aliyuncs.com/images/20151031191555638&quot; style=&quot;zoom: 50%;&quot;&gt;  
  &lt;/a&gt;</code></pre>
</div></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://despairl.github.io/2022/04/06/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yanquan Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQBlog | HaveFun!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-06 19:37:36" itemprop="dateCreated datePublished" datetime="2022-04-06T19:37:36+08:00">2022-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-26 13:33:23" itemprop="dateModified" datetime="2022-04-26T13:33:23+08:00">2022-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>要求:</p>
<ul>
<li>熟悉相关网络协议规范，如TCP/IP或3GPP</li>
<li>熟悉测试基础理论，如黑盒和白盒测试方法</li>
<li>对无线通信、数通、传输、云计算等某一领域的知识有一定了解，熟悉通信网络基础知识</li>
</ul>
<h4 id="osi七层模型和tcpip五层模型">OSI七层模型和TCP/IP五层模型</h4>
<p>OSI七层模型从上到下依次为：</p>
<ul>
<li><p>应用层：为应用程序提供<strong>网络服务</strong>；</p></li>
<li><p>表示层：数据格式转换、数据压缩和数据加密；</p></li>
<li><p>会话层：建立、断开和维护<strong>通信链接</strong>；</p></li>
<li><p>传输层：为上层协议提供<strong>端到端的可靠传输</strong>；</p></li>
<li><p>网络层：寻址和路由；<strong>（路由器，传的是IP数据报，选址、路由）</strong></p></li>
<li><p>数据链路层：定义通过通信媒介互连的设备之间传输的规范； <strong>(交换机)</strong></p></li>
<li><p>物理层：利用<strong>物理传输介质为数据链路层提供物理连接</strong>。</p></li>
</ul>
<p>TCP五层模型相比OSI七层模型，将OSI的<strong>应用层、表示层和会话层合为一层：应用层，其他不变</strong>。</p>
<h4 id="端到端">端到端</h4>
<p>AI : 尽量让模型直接从输入到输出一条都自己搞定，减少人工成分。</p>
<p>网络： 节点相连即可。</p>
<h4 id="面向有连接型和面向无连接型">面向有连接型和面向无连接型</h4>
<ul>
<li><strong>面向有连接型传输</strong>包括<strong>会话建立、传输数据和会话断开</strong>，此外还包括保证传输可靠性的各种措施，比如超时重传、流量控制等，常见的<strong>面向有连接传输有TCP</strong>；</li>
<li><strong>面向无连接型传输</strong>仅提供<strong>基本的传输数据</strong>的功能，即使<strong>接收端不存在，发送端也能发送数据</strong>包，常见的<strong>面向无连接传输有UDP、IP</strong>。</li>
</ul>
<h4 id="tcpudpip">TCP/UDP/IP</h4>
<ul>
<li><p>UDP和TCP都是<strong>传输层的协议</strong>，用来建立可靠的通信传输链接的。TCP : <strong>Transmission Control Protocol</strong></p></li>
<li><p><strong>IP</strong>位于网络层，Internet Protocol。</p></li>
<li><p>TCP/IP 包含了一组其他协议(UDP,ICMP,TCP,IP...)</p></li>
</ul>
<p><strong>UDP</strong>仅提供了<strong>最基本的数据传输</strong>功能，至于<strong>传输时连接的建立和断开、传输可靠性的保证</strong>这些UDP<strong>统统不关心</strong>，而是<strong>把这些问题抛给了UDP上层的应用层</strong>程序去处理，自己<strong>仅提供传输层协议的最基本功能</strong>。<strong>面向无连接</strong>。</p>
<p><strong>TCP</strong>作为一种<strong>面向有连接</strong>的协议，<strong>只有在确认通信对端存在时才会发送数据</strong>，会在传输开始前建立连接，传输结束后断开连接，此外，<strong>TCP还采取了多种措施保障传输的可靠性</strong>。</p>
<p>TCP和UDP的区别如下：</p>
<ul>
<li>TCP是面向有连接型，UDP是面向无连接型；</li>
<li>TCP是<strong>一对一传输</strong>，UDP支持<strong>一对一、一对多、多对一和多对多</strong>的交互通信；</li>
<li>TCP是<strong>面向字节流</strong>的，即<strong>把应用层传来的报文看成字节流</strong>，<strong>将字节流拆分成大小不等的数据块</strong>，并<strong>添加TCP首部</strong>；UDP是<strong>面向报文</strong>的，对应用层传下来的<strong>报文不拆分也不合并</strong>，<strong>仅添加UDP首部</strong>；</li>
<li>TCP支持传输可靠性的多种措施，包括保证包的传输顺序、重发机制、流量控制和拥塞控制；UDP仅提供最基本的数据传输能力。</li>
</ul>
<h3 id="tcp对应的应用层协议有哪些udp对应的应用层协议有哪些">TCP对应的应用层协议有哪些？UDP对应的应用层协议有哪些？</h3>
<ul>
<li>典型的应用层协议：
<ul>
<li>FTP：文件传输协议；</li>
<li>SSH：远程登录协议；</li>
<li>HTTP：web服务器传输超文本到本地浏览器的超文本传输协议。</li>
</ul></li>
<li>UDP对应的典型的应用层协议：
<ul>
<li>DNS：域名解析协议；</li>
<li>TFTP：简单文件传输协议；</li>
<li>SNMP：简单网络管理协议。</li>
</ul></li>
</ul>
<h3 id="tcp-三次挥手建立连接四次挥手断开连接">TCP 三次挥手建立连接，四次挥手断开连接</h3>
<ul>
<li><p>三次握手的实质就是填充一个表格:</p>
<ul>
<li><img src="https://admirelotusimagebed.oss-cn-hangzhou.aliyuncs.com/images/image-20220410155529349.png" alt="image-20220410155529349" style="zoom:50%;" /></li>
</ul></li>
<li><p>TCP报文首部 :</p>
<ul>
<li><p>序号seq(对<strong>字节流的编号</strong>),确认号ack(期望收到的<strong>下一个报文段的序号</strong>),SYN(用于建立连接，该位设为 1，表示<strong>希望建立连接</strong>,对第一份报文的序号进行随机初始化),ACK(确认应答的字段有效，<strong>TCP规定除了最初建立连接时的 SYN 包以外该位必须设为 1</strong>),FIN(控制位的一种，当<strong>FIN=1</strong>，表明此报文的<strong>发送方的数据已经发送完毕，要求关闭连接</strong>)</p></li>
<li><p>第一次握手 :</p>
<ul>
<li>Client端<strong>将SYN置为1</strong>，表示<strong>希望与Server端建立连接</strong>；序号seq<strong>初始化为J</strong>，并将该数据包发送给Server端，Client进入<strong>SYN_SENT</strong>状态，等待<strong>Server确认</strong>。</li>
</ul></li>
<li><p>第二次握手</p>
<ul>
<li>Server端<strong>检查报文发现SYN为1</strong>，知道了<strong>Client端想建立连接</strong>；Server端将<strong>SYN置为1，表示Server端也希望与Clinet端建立连接</strong>；Server端将<strong>ACK置为1</strong>，表示收到了Client端建立连接的请求；Server端将<strong>seq初始化为K</strong>；Server端将<strong>ack置为J+1</strong>，这里<strong>ack=seq + 1</strong></li>
</ul></li>
<li><p>第三次握手</p>
<ul>
<li>Client收到报文后，<strong>检查ack是否为J+1</strong>，<strong>ACK是否为1</strong>，如果正确则将标志位<strong>ACK置为1，ack=K+1</strong>，并将该数据包发送给Server，Server<strong>检查ack是否为K+1，ACK是否为1</strong>，如果正确则连接<strong>建立成功</strong>，Client和Server进入<strong>ESTABLISHED</strong>状态，<strong>完成三次握手，随后Client与Server之间可以开始传输数据</strong>了。</li>
</ul></li>
<li><p>为什么不是2次握手？因为<strong>2次握手表格填充不完</strong>，<strong>源端和目的端无法确认双方的收发能力</strong>；为什么不是4次握手？<strong>3次握手表格就填充完毕了，不需要再多一次握手了</strong>。</p></li>
</ul></li>
<li><p><strong>四次挥手是断开TCP连接</strong>，即客户端和服务端总共要收发4个包才能确定断开连接。</p>
<ul>
<li>第一次挥手:
<ul>
<li>客户端<strong>主动发起断开请求</strong>，客户端向服务端<strong>发送报文，报文首部包括FIN=1</strong>，这个控制位代表<strong>客户端想要断开连接</strong>；<strong>序列号seq=u，这时客户端进入FIN-WAIT-1（终止等待1）</strong>状态，停止发送数据，并<strong>等待服务端的确认</strong>。</li>
</ul></li>
<li>第二次挥手:
<ul>
<li><strong>服务端收到客户端的报文后发出确认报文</strong>，控制位<strong>ACK=1；确认号ack=u+1；序列号seq=v</strong>；然后<strong>服务端就进入CLOSE-WAIT（关闭等待）</strong>状态。TCP<strong>服务端会告知上层的应用进程</strong>来自<strong>客户端的连接即将关闭</strong>，让应用程序做好相应的准备。此时<strong>客户端已经没有数据向服务端发送</strong>了，但<strong>服务端向客户端发送数据，客户端依然能接收</strong>。</li>
</ul></li>
<li>第三次挥手:
<ul>
<li><strong>客户端收到服务器确认报文</strong>后，进入<strong>FIN-WAIT-2</strong>状态。此时<strong>服务器再次发送报文，报文首部控制位FIN=1</strong>，表示<strong>服务端向客户端发送断开连接请求</strong>；确认标志<strong>ACK=1；确认序号ack=u+1</strong>；<strong>序号seq=w</strong>，然后服务器进入<strong>LAST-ACK</strong>（最后确认态），等待客户端确认。</li>
</ul></li>
<li>第四次挥手:
<ul>
<li><strong>客户端收到了服务端的断开连接的报文</strong>后，必须<strong>发出确认报文</strong>，标志位ACK=1；确认号ack=w+1;序号seq=u+1；之后<strong>客户端就进入了TIME-WAIT（时间等待）</strong>状态。注意此时<strong>客户端的TCP连接还没有释放</strong>，必须经过**2*MSL（最长报文段寿命）<strong>的时间后，</strong>客户端才进入CLOSED状态关闭连接<strong>。而</strong>服务端只要收到了客户端发送的确认报文后就会进入CLOSED状态关闭服务端连接<strong>。当</strong>客户端和服务端都进入了CLOSED状态<strong>后，客户端和服务端之间的连接</strong>才完全断开**。</li>
</ul></li>
</ul></li>
<li><p>为什么是四次挥手而不是三次或者五次？</p>
<ul>
<li><strong>第二次挥手是服务端收到了客户端的断开请求</strong>，通知客户端俺收到了，此时客户端没有数据向服务端发送了，但不代表服务端也没有数据向客户端发送，因为<strong>服务端要把剩余还没有发送的报文发送完毕再断开连接</strong>；<strong>第三次挥手是服务端数据全部发送完毕</strong>，<strong>向客户端发送断开请求报文（FIN=1）</strong>。</li>
<li>如果是三次挥手，即把服务端向客户端发送报文的第二次挥手和第三次挥手合为一次，<strong>会造成服务端发送了回执后立刻又发送断开请求</strong>，造成<strong>服务端有数据没有全部发送至客户端</strong>，因此必须将第二次挥手和第三次挥手分开；<strong>五次挥手则完全没必要，多此一举</strong>。</li>
</ul></li>
<li><p>为什么会有TIME_WAIT状态?</p>
<ul>
<li><strong>客户端发送给服务端回执</strong>后，有可能这个回执报文在传输途中丢失等原因，<strong>服务端并没有收到</strong>，此时<strong>服务端会再次向客户端发送FIN=1的断开请求报文</strong>，如果**客户端没有等待2*MSL时间而直接进入了CLOSED状态<strong>，</strong>客户端就会收不到服务端再次发送的断开连接的请求报文<strong>，</strong>导致服务端无法进入CLOSED状态**；</li>
<li>等待一段时间是为了<strong>让本连接持续时间内所产生的所有报文都从网络中消失</strong>，<strong>使得下一个新的连接不会出现旧的连接请求报文</strong>。</li>
</ul></li>
</ul>
<h3 id="arq协议">ARQ协议</h3>
<ul>
<li><p><strong>自动重传请求（Automatic Repeat-reQuest）</strong>，意思是如果发送方在发送后一段时间之内没有收到确认回执，它通常会重新发送。<strong>ARQ协议包括停止等待ARQ协议和连续ARQ协议</strong>。</p></li>
<li><p><strong>停止等待ARQ协议</strong></p>
<ul>
<li>在停止等待中如果接收端没有收到发送端发来的分组，接收端就不会给发送端发送确认回执，此时发送端会重新发送之前的报文分组。发送端会维护一个超时计时器，超时时间会设置的比数据在传输往返过程的时间要长一些。</li>
</ul></li>
<li><p><strong>连续ARQ协议</strong></p>
<ul>
<li><p>发送端维护一个“窗口”，“窗口”内可以有多个分组，窗口的大小就是窗口中分组的个数，凡是位于“窗口”内的分组可以连续发送出去而不必等待接收端返回的确认回执，对按序到达的最后一个分组，接收端会向发送端发送确认回执，如果有分组没有正确到达，会返回最后一个正确达到的分组序号，该序号后面的分组会重新发送给接收端。</p></li>
<li><p>举个例子，窗口大小为4，发送时第1、2、4号分组均成功发送，3号分组发送失败，接收端会给发送端发送2号分组的确认回执，然后发送端会把2号分组之后的数据（3号分组和4号分组）重新再发送一遍，即使4号分组是发送成功的。</p></li>
<li><p>在连续ARQ协议中，发送端会维护一块发送端的数据缓存，“窗口”里的分组都会在这个缓存中，当需要重新发送“窗口”中的分组报文时，便会从缓存里读取分组并发送。</p>
<p>连续 ARQ 协议可提高信道利用率。</p></li>
</ul></li>
</ul>
<h3 id="tcp的流量控制">TCP的流量控制</h3>
<ul>
<li>接收端会通知发送端自己能接收的数据大小，于是发送端会发送不超过这个数据量的数据，这个大小被称为“窗口”的大小，在TCP首部中专门有一个字段表示“窗口”的大小，该值越大代表网络的吞吐量越高。</li>
<li>为了控制发送端发送数据的速率，保证接收端能将本应接收的所有报文分组接收成功，否则会触发自动重传机制造成网络流量的浪费。</li>
</ul>
<h3 id="tcp的拥塞控制">TCP的拥塞控制</h3>
<ul>
<li>慢启动、拥塞避免、快重传与快恢复</li>
<li><strong>慢启动 :</strong>
<ul>
<li>在通信开始时，<strong>定义一个“拥塞窗口”，窗口大小为1</strong>，意思是开始时<strong>只发送一个分组</strong>，之后<strong>每收到一个确认回执（ACK），拥塞窗口的大小就加1</strong>（即逐渐增大窗口大小），发送端在发送数据时，将<strong>拥塞窗口的大小与接收端流量控制窗口的大小作比较</strong>，<strong>取二者中较小的值</strong>，然后实际发送的数据量<strong>比这个最小值还要小</strong>。</li>
</ul></li>
</ul>
<h3 id="tcp-粘包">TCP 粘包</h3>
<ul>
<li>TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP <strong>把这些数据块仅仅看成一连串无结构的字节流，没有边界</strong>；</li>
<li>从 TCP 的<strong>帧结构</strong>也可以看出，在 <strong>TCP 的首部没有表示数据长度</strong>的字段。</li>
<li>如果客户端<strong>连续不断的向服务端发送数据包</strong>时，服务端接收的数据会出现<strong>两个数据包粘在一起</strong>的情况。</li>
<li>为什么会这样?
<ul>
<li>client : 当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。<strong>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包</strong>。</li>
<li>server: 数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（<strong>放数据的速度 &gt; 应用层拿数据速度</strong>）。<strong>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包</strong></li>
</ul></li>
<li>改进:
<ul>
<li>在每个包的<strong>末尾加上特殊字符</strong>，用以区分连续的两个包；</li>
<li>在<strong>报文首部添加包的长度</strong>。</li>
</ul></li>
</ul>
<h3 id="httphttps">http/https</h3>
<ul>
<li>http协议是应用层的协议，中文名称是超文本传输协议,客户端和服务端相互通信时将信息以http报文的形式传输
<ul>
<li>http 缺点:
<ul>
<li>通信双方的<strong>身份无法得到认证</strong>,<strong>身份可能遭遇伪装</strong></li>
<li><strong>无法验证报文的完整性</strong></li>
<li>通信使用明文，<strong>内容可能被窃听</strong></li>
</ul></li>
<li>http协议是一种无状态协议，协议自身<strong>不对请求和响应之间的通信状态进行保存</strong>，即对发送过来的请求和响应都不做持久化处理，把http协议设计的如此简单是<strong>为了更快地处理大量事务。</strong>
<ul>
<li>怎么解决<strong>Http协议无状态协议</strong> ?
<ul>
<li><strong>Cookie状态管理</strong>。Cookie技术通过<strong>在请求和响应报文中写入Cookie信息</strong>来控制<strong>客户端的状态</strong>。Cookie会根据从服务端发送的响应报文的一个叫<strong>Set-Cookie的首部字段，通知客户端保存Cookie</strong>。当<strong>下次客户端再往该服务端发送请求</strong>时，<strong>客户端会自动在请求报文中加入Cookie值</strong>发送出去，<strong>服务端发现客户端发来的Cookie</strong>后，会检查<strong>是哪一个客户端发来的连接请求</strong>，<strong>对比服务器上的记录</strong>，最后<strong>得到之前的状态信息</strong>。</li>
</ul></li>
</ul></li>
</ul></li>
<li>https可以简单的理解为：https = http + 加密 + 认证 + 完整性保护。
<ul>
<li>加密。https协议<strong>通过SSL或者TLS协议将报文内容进行加密</strong>，<strong>client端进行加密</strong>，<strong>server端进行解密</strong>。</li>
<li>认证。通过<strong>值得信赖的第三方机构颁布证书</strong>，即可确认通信双方的身份。<strong>客户端持有证书即可完成客户端身份</strong>的确认，<strong>客户端通信前会查看服务端的证书</strong>。</li>
<li>完整性保护。可以通过<strong>MD5等散列码</strong>进行通信内容的校验。</li>
</ul></li>
</ul>
<h3 id="常用的http动词">常用的http动词</h3>
<ul>
<li>```text GET: 从服务器 获取 资源 POST: 在服务器 新建 资源 PUT: 在服务器 更新 资源 DELETE: 在服务器 删除 资源 HEAD: 获取资源的 元数据 OPTIONAL: 查询 对指定的资源支持的方法 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ **post在发请求**的时候，**服务器会每次都创建一个文件**，而**put**发请求的时候，是**更新文件而不是创建文件**，因此put是幂等的。</span><br><span class="line"></span><br><span class="line">### http请求报文和响应报文</span><br><span class="line"></span><br><span class="line">### 常见的http返回码</span><br><span class="line"></span><br><span class="line">- 200：请求被**正常处理**</span><br><span class="line">- 204：**请求被受理**但**没有资源可以返回**</span><br><span class="line">- 206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</span><br><span class="line">- 301：**永久性重定向**</span><br><span class="line">- 302：**临时重定向**</span><br><span class="line">- 303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</span><br><span class="line">- 304：发送附带条件的请求时，条件不满足时返回，与重定向无关</span><br><span class="line">- 307：临时重定向，与302类似，只是强制要求使用POST方法</span><br><span class="line">- 400：**请求报文语法**有误，服务器无法识别</span><br><span class="line">- 401：**请求需要认证**</span><br><span class="line">- 403：请求的对应资源**禁止被访问**</span><br><span class="line">- 404：**服务器无法找到对应资源**</span><br><span class="line">- 500：**服务器内部错误**</span><br><span class="line">- 503：**服务器正忙**</span><br><span class="line"></span><br><span class="line">### URI和URL的区别</span><br><span class="line"></span><br><span class="line">+ URL: Uniform Resource **Locator**，**统一资源定位符**，我们访问网站的网址就是URL。</span><br><span class="line">+ URI: Uniform Resource **Identifier**，**统一资源标识符**，用来唯一标识互联网中的一份资源.</span><br><span class="line">+ URL是URI的子集。URI的目的就是**唯一标识互联网中的一份资源**，具体可以用资源名称、资源地址等，但是资源地址是目前使用最广泛的，因此URL就容易和URI混淆。**URI相当于抽象类，URL就是这个抽象类的具体实现类。**</span><br><span class="line">    + 一句话， **URL属于URI的一个实例**。</span><br><span class="line"></span><br><span class="line">### c++类与C里的Struct的区别</span><br><span class="line"></span><br><span class="line">+ Struct默认成员是public，c++ class默认是private的，在c++中结构可以看成是特殊的类。</span><br><span class="line">+ class它更侧重于概念，struct保证在内存中按照声明顺序存储，class不保证。</span><br><span class="line"></span><br><span class="line">### 析构函数</span><br><span class="line"></span><br><span class="line">+ 特殊的类成员函数，没有返回类型、没有参数，由系统自动在类对象的生命期结束时调用。</span><br><span class="line"></span><br><span class="line">### 虚函数</span><br><span class="line"></span><br><span class="line">+ virtual 标识主要用于 子类继承父类的方法，默认采用父类作为模板，此时我们可以将父类的方法标为virtual. 方便子类中实现多态。</span><br><span class="line">+ 如果父类完全没必要实现，可以写 virtual &lt;函数名&gt; = 0,由子类完全写。</span><br><span class="line"></span><br><span class="line">### 全局变量与局部变量</span><br><span class="line"></span><br><span class="line">+ 全局变量在哪都能被调用，但是局部变量只有在部分作用域中被调用。</span><br><span class="line"></span><br><span class="line">+ 全局变量在编译的时候会被存放在数据段，局部变量是存放在堆栈段。</span><br><span class="line"></span><br><span class="line">### 寄存器</span><br><span class="line"></span><br><span class="line">+ 寻址方式(指令中操作数所在的方法称为寻址方式): 直接寻址，寄存器间接寻址，寄存器相对寻址，基址加变址寻址，相对基址加变址寻址</span><br><span class="line"></span><br><span class="line">+ 固定寻址、I/O端口寻址</span><br><span class="line"></span><br><span class="line">+ 内存的分配和回收整理</span><br><span class="line"></span><br><span class="line">### 8086 80386</span><br><span class="line"></span><br><span class="line">+ 8086 是 16位，80386是32位</span><br><span class="line"></span><br><span class="line">### 白箱测试、黑箱测试、回归测试</span><br><span class="line"></span><br><span class="line">+ 白箱测试：</span><br><span class="line">    + 按照**程序内部逻辑测试程序**,检查程序中的每条通路是否按照预定要求正确工作.它主要的针对被测程序的源代码,测试着可以完全不考虑程序的功能.</span><br><span class="line">    + **对过程性细节进行细致检查**</span><br><span class="line">    + **白盒测试流程**  **源程序**--&gt;分析程序内部逻辑结构--&gt;流程图--&gt;制定[测试用例](https://so.csdn.net/so/search?q=测试用例&amp;spm=1001.2101.3001.7020)--&gt;被测程序--&gt;执行路径--&gt;覆盖情况分析</span><br><span class="line">    + 主要用于自动化测试</span><br><span class="line">    + 缺点：</span><br><span class="line">        + 对测试人员要求很高，不但要能够阅读代码还要有一定的算法分析能力。</span><br><span class="line">    + 主要方法：</span><br><span class="line">        + 语句覆盖、判定覆盖、条件覆盖、路径覆盖</span><br><span class="line">            + 语句覆盖 : **每个可执行语句都走一遍即可，即测试用例要覆盖所有的语句**</span><br><span class="line">            + 判定覆盖 : 要设定True和False的两种案例；与[语句覆盖](https://so.csdn.net/so/search?q=语句覆盖&amp;spm=1001.2101.3001.7020)不同的是增加了False的情况</span><br><span class="line">            + 条件覆盖 : 针对判断语句里面案例的取值都要去一次，不考虑条件的取值</span><br><span class="line">            + 路径覆盖 : **走完所有的路径** </span><br><span class="line">    </span><br><span class="line">+ 黑箱测试：</span><br><span class="line">    + 是根据功能需求来测试程序是否按照预期工作,是要**从用户的角度**分析.尽量发现**代码所表现的外部行为的错误**.[黑盒测试](https://so.csdn.net/so/search?q=黑盒测试&amp;spm=1001.2101.3001.7020)应该是由测试团队来完成的.根据某个给定的输入,应该能够理解并详细说明程序的预期输出.</span><br><span class="line">    </span><br><span class="line">    + **完全不考虑程序内部结构、内部特性**，**仅仅针对软件界面与软件功能**进行测试。</span><br><span class="line">    </span><br><span class="line">    + **黑箱测试流程** ：**功能需求**--&gt;产生测试用例--&gt;被测程序--&gt;输出实际结果--&gt;与预期结果比较--&gt;分析功能是否实现</span><br><span class="line">    </span><br><span class="line">    + 优点:</span><br><span class="line">    </span><br><span class="line">        + 容易上手</span><br><span class="line">        + 功能性测试与软件如何实现无关，如果实现发生变化，功能性测试仍然可用</span><br><span class="line">        + 测试用例编写与软件开发同时进行，节省软件开发时间</span><br><span class="line">        + 通过软件的用例可用设计出大部分功能性测试用例</span><br><span class="line">    </span><br><span class="line">    + 缺点：</span><br><span class="line">        + 不了解代码的效率极低，边界值都不好找</span><br><span class="line">        + 测试用例数量大,可能产生很多冗余</span><br><span class="line">        + 功能性测试的覆盖范围不可能达到100%</span><br><span class="line">    </span><br><span class="line">    + 主要方法：</span><br><span class="line">        + 等价类划分、边值分析、因果图、数据准确性、场景法(模拟)、错误猜想(列出程序中所有可能存在错误和容易发生的错误)</span><br><span class="line">    </span><br><span class="line">        + **首先采用等价类划分法来编写测试用例**,**必要时采用边界值分析法进行补充测试用例**,</span><br><span class="line">    </span><br><span class="line">            **采用错误推测法再追加测试用例**,**对照程序逻辑，检查自己设计出的测试用例逻辑覆盖程度，若覆盖不够，则需要再补充其他的测试用例**,**如果程序功能含有输入条件的组合情况，应一开始就采用因果图法** ,**如果程序某功能适合自动测试，可以采用自动化测试及随机测试。** </span><br><span class="line">    </span><br><span class="line">        + 等价类划分 : 把**所有可能输入**的数据，主要是将程序输入分为若干部分，从每一部分中选取具有可代表性数据作为设计测试用例的一种方式方法。</span><br><span class="line">    </span><br><span class="line">        + 边值分析 : 要选取正好等于或刚刚大于和小于边界的值进行分析</span><br><span class="line">    </span><br><span class="line">        + 因果图法 : </span><br><span class="line">    </span><br><span class="line">            列出原因、结果、设计中间状态、画因果图、判定表</span><br><span class="line">    </span><br><span class="line">            &lt;img src=&quot;https://admirelotusimagebed.oss-cn-hangzhou.aliyuncs.com/images/image-20220410112343127.png&quot; alt=&quot;image-20220410112343127&quot; style=&quot;zoom:50%;&quot; /&gt; </span><br><span class="line">    </span><br><span class="line">            &lt;img src=&quot;https://admirelotusimagebed.oss-cn-hangzhou.aliyuncs.com/images/image-20220410112406679.png&quot; alt=&quot;image-20220410112406679&quot; style=&quot;zoom:50%;&quot; /&gt; </span><br><span class="line">    </span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">+ **回归测试:**</span><br><span class="line">  </span><br><span class="line">    + 在对软件进行修正后进行的有选择的重新测试过程.**一般要重复已用的测试用例.**目的是检验软件在更改后所引起的错误,**验证软件在修改后未引起不希望的有害效果**.</span><br><span class="line">    </span><br><span class="line">+ **灰盒测试**:</span><br><span class="line"></span><br><span class="line">    + 基于**程序运行时的外部表现又结合程序内部逻辑结构**来设计测试用例。</span><br><span class="line">    + 灰盒测试**通常在程序员做完白盒测试之后**，在**功能测试人员进行大规模集成测试**之前。</span><br><span class="line">    + 灰盒测试是通过类似白盒测试的方法进行的，是通过**编写代码、调用函数或者封装好的接口**进行，但**无需关心程序内部的实现细节**，依然可把它当成一个黑盒。灰盒测试是**有测试人员**进行的。</span><br><span class="line">    + </span><br><span class="line"></span><br><span class="line">### 一套完整的测试应该由哪些阶段组成</span><br><span class="line"></span><br><span class="line">+ **测试计划** </span><br><span class="line">    + 根据**用户需求报告**中关于**功能要求和[性能指标](https://so.csdn.net/so/search?q=性能指标&amp;spm=1001.2101.3001.7020)**的规格说明书，定义相应的测试需求报告，即制订**黑盒测试的最高标准**，以后所有的测试工作都将围绕着测试需求来进行。适当选择测试内容，合理安排测试人员、测试时间及测试资源等。</span><br><span class="line">+ **测试设计**</span><br><span class="line">    + 将测试计划阶段制订的测试**需求分解**、**细化为若干个可执行的测试过程**，并**为每个测试过程选择适当的测试用例**</span><br><span class="line">+ **测试开发**</span><br><span class="line">    + 建立**可重复使用**的**自动测试**过程</span><br><span class="line">+ **测试执行**</span><br><span class="line">    + 执行**测试开发阶段建立的自动测试过程**，并对**所发现的缺陷进行跟踪管理**。测试执行一般由**单元测试、组合测试、集成测试、系统联调及回归测试**等步骤组成</span><br><span class="line">+ **测试评估**</span><br><span class="line">    + 结合**量化的测试覆盖域**及**缺陷跟踪报告**，对于**应用软件的质量**和开发团队的工作进度及工作效率进行**综合评价**。</span><br><span class="line"></span><br><span class="line">### 单元测试、组合测试、集成测试、系统联调及回归测试</span><br><span class="line"></span><br><span class="line">+ 静态测试又可分为代码走查（Walkthrough），代码审查(Inspection)，技术评审(Review)。</span><br><span class="line"></span><br><span class="line">+ 单元测试</span><br><span class="line"></span><br><span class="line">    + 目的是检验软件基本组成单位的正确性。**测试的对象是软件里测试的最小单位：模块**。</span><br><span class="line">    + 测试驱动开发（TDD）：测试人员**先编写测试用例**，开发人员**根据测试用例**写程序</span><br><span class="line">    + 孤立的单元测试策略（Isolation Unit Testing纯粹，可并行（同时，并发是同时间段））、自顶向下的单元测试策略（Top Down Unit Testing）、自底向上的单元测试策略（Bottom Up Unit Testing）</span><br><span class="line"></span><br><span class="line">+ 集成测试</span><br><span class="line"></span><br><span class="line">    + 测试阶段：一般是单元测试之后</span><br><span class="line"></span><br><span class="line">        测试对象：模块间的接口</span><br><span class="line"></span><br><span class="line">        测试方法：黑盒测试与白盒测试（灰盒测试）</span><br><span class="line"></span><br><span class="line">    + **模块之间**数据传输、模块之间功能冲突、模块组装功能的正确性、全局数据结构、单模块缺陷对系统的影响</span><br><span class="line"></span><br><span class="line">+ 确认测试的目标是验证软件的功能和性能是否与用户的要求一致</span><br><span class="line"></span><br><span class="line">+ 系统测试</span><br><span class="line"></span><br><span class="line">    + 将软件系统看成是一个系统的测试。包括对功能、性能以及软件所运行的软硬件环境进行测试。时间大部分在系统测试执行阶段，包括回归测试和冒烟测试。</span><br><span class="line">    + 黑盒测试工程师</span><br><span class="line">    + **先冒烟、再系统、后回归。**</span><br><span class="line">    + 冒烟测试就是指**这个软件是否具备可测性，也叫做可测性测试**，冒烟测试针对的是完整的软件版本，换句话说就是对基本功能进行测试，而不涉及一些深入内容的测试</span><br><span class="line">    + 系统测试包括了**功能测试**,**性能测试**，**协议一致性测试**,**压力测试**,**容量测试**，**安全性测试**，**失效恢复测试**，**备份测试**，**GUI测试**，**健壮性测试**，**兼容性测试**,**易用性测试**,**安装测试**,**数据转换测试**,**在线帮助测试**,**文档测试**</span><br><span class="line"></span><br><span class="line">+ 验收测试</span><br><span class="line"></span><br><span class="line">    + 也称为交付测试。验收测试的目的是确保软件准备就绪，按照项目合同、任务书、双方约定的验收依据文档，向软件购买者展示该软件系统满足原始需求。</span><br><span class="line"></span><br><span class="line">    + 测试对象：整个系统（包括软硬件）</span><br><span class="line"></span><br><span class="line">        测试人员：主要是最终用户或者需求方</span><br><span class="line"></span><br><span class="line">        黑盒测试</span><br><span class="line"></span><br><span class="line">    + 验收测试包括alpha测试和beta测试。**alpha测试是由一个用户在开发环境下进行的测试**，也可以是**公司内部的用户在模拟实际操作环境下进行的测试**。**Beta测试由软件的最终用户们在一个或多个客房场所进行。** </span><br><span class="line"></span><br><span class="line">### **软件测试的流程是什么**</span><br><span class="line"></span><br><span class="line">项目经理或者PD把项目需求文档提前下发给相关的研发人员，研发人员抽出一定的时间记录文档内需求不明确或者遗漏的点为后面的评审做准备；在需求评审会议上，各研发人员提出自己的疑问并解决，需求评审最终通过之后会出一份最终的需求规格说明书；**（需求评审阶段）**</span><br><span class="line"></span><br><span class="line">需求规格说明书评审通过后，开发经理开始编写开发计划，测试经理开始编写测试计划，计划评审通过后开发人员开始进行程序的开发，测试人员开始测试用例的编写，等程序的第一个版本出来后，开发人员进行第二个版本的迭代，这时测试人员对程序进行测试并记录追踪管理缺陷，直到程序迭代完毕。**（产品研发阶段）**</span><br><span class="line"></span><br><span class="line">程序迭代完毕并修复大部分缺陷后，测试人员开始进行工作的总结，并最终输出一份测试报告书，记录此次的测试工作共，程序存在的相关问题。**（产品发布阶段）**</span><br><span class="line"></span><br><span class="line">### **软件测试有什么策略和阶段**</span><br><span class="line"></span><br><span class="line">软件测试的策略主要有：动态测试和静态测试、白盒测试和黑盒测试。测试阶段按照研发顺序分别是：[单元测试](https://www.zhihu.com/search?q=单元测试&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=&#123;&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1403232950&#125;)、集成测试、系统测试，有些公司还会有验收测试；**（单元测试开发在调试代码时就完成，集成测试也是，但是有时测试人员也需要进行集成测试；测试人员平时主要的工作就是系统测试，验收测试是有客户参与进行的测试）；**</span><br><span class="line"></span><br><span class="line">### **软件测试有什么类型**</span><br><span class="line"></span><br><span class="line">常见的软件测试类型有:功能测试、性能测试、兼容性测试、可靠性测试、安全性测试、压力测试、负载测试等；</span><br><span class="line"></span><br><span class="line">### **测试用例主要有哪些元素**</span><br><span class="line"></span><br><span class="line">测试用例主要元素有：ID、标题、模块、预置条件、操作步骤、预期结果、实际结果、是否通过、BugID等；</span><br><span class="line"></span><br><span class="line">### 软件缺陷的定义</span><br><span class="line"></span><br><span class="line">1、软件未实现需求规格说明书中的要求；</span><br><span class="line"></span><br><span class="line">2、出现需求规格说明书中指明不应该出现的错误；</span><br><span class="line"></span><br><span class="line">3、软件未实现需求文档中虽未明确提及但应该实现的功能；（如：账密加密）</span><br><span class="line"></span><br><span class="line">4、软件出现难以理解、不易使用或者运行速度慢等问题都可以认为是软件缺陷；</span><br><span class="line"></span><br><span class="line">缺陷密度值达到客户的要求就可以算通过</span><br><span class="line"></span><br><span class="line">**缺陷的生命周期:** </span><br><span class="line"></span><br><span class="line">+ 提交-&gt;确认-&gt;分配-&gt;修复-&gt;验证-&gt;关闭</span><br><span class="line"></span><br><span class="line">### 为什么做测试</span><br><span class="line"></span><br><span class="line">PA中遇到了很多bug自己排查花了很长时间，想更多地了解一些测试的内容。</span><br><span class="line"></span><br><span class="line">### 测试与开发</span><br><span class="line"></span><br><span class="line">测试（testing）是检验软件系统是不是满足规定的要求，找出与预期的差异，并且跟踪和修复的过程。 从工作内容上，简单一点来说，编程开发就是创造和实现功能，软件测试就是检验、检查这个过程中有没有什么缺陷和遗漏。</span><br><span class="line"></span><br><span class="line">### MySQL</span><br><span class="line"></span><br><span class="line">**增：**insert into 表名（列名） values （数据）;</span><br><span class="line"></span><br><span class="line">**删：**delete from 表名 where 指定数据;</span><br><span class="line"></span><br><span class="line">**改：**update 表名 set 改变项 where 指定数据;</span><br><span class="line"></span><br><span class="line">**查：**select （查询项） from 表名 where 指定条件;</span><br><span class="line"></span><br><span class="line">### 软件开发生命周期(SDLC)</span><br><span class="line"></span><br><span class="line">+ 需求-&gt;设计-&gt;建设、开发-&gt;测试-&gt;交互-&gt;维护</span><br><span class="line"></span><br><span class="line">### STLC(软件测试生命周期)</span><br><span class="line"></span><br><span class="line">+ 需求分析 -&gt; 测试计划 -&gt; 环境设置 -&gt; 测试用例 -&gt; 缺陷记录 -&gt; 测试周期</span><br><span class="line"></span><br><span class="line">### 类string的构造函数、析构函数和赋值函数</span><br><span class="line"></span><br><span class="line">+ ```c++</span><br><span class="line">    </span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line">    class String</span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">    	String(const char *str=NULL);            //普通构造函数</span><br><span class="line">    	String(const String &amp;other);             //复制构造函数</span><br><span class="line">    	~String(void);                           //析构函数</span><br><span class="line">    	String &amp; operator=(const String &amp;other);//赋值函数</span><br><span class="line">    private:</span><br><span class="line">    	char *m_String;                        //私有成员，保存字符串</span><br><span class="line">    &#125;;</span><br><span class="line">    String::String(const char *str)</span><br><span class="line">    &#123;</span><br><span class="line">    	if(str==NULL)                         //如果str为空，存空字符串</span><br><span class="line">    	&#123;</span><br><span class="line">    		m_String=new char[1];             //分配一个字节</span><br><span class="line">    		*m_String=&#x27;\0&#x27;;                  //将之赋值为字符串结束符</span><br><span class="line">    	&#125;</span><br><span class="line">    	else</span><br><span class="line">    	&#123;</span><br><span class="line">    		m_String=new char[strlen(str)+1]; //分配空间容纳str内容</span><br><span class="line">    		strcpy(m_String,str);             //赋值str到私有成员 </span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String::String(const String &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">    	m_String=new char[strlen(other.m_String)+1];</span><br><span class="line">    	strcpy(m_String,other.m_String);</span><br><span class="line">    &#125;</span><br><span class="line">    String::~String(void)</span><br><span class="line">    &#123;</span><br><span class="line">    	if(m_String!=NULL)                    //如果m_String 不为NULL，释放堆内存</span><br><span class="line">    	&#123;</span><br><span class="line">    		delete [] m_String;              //释放后置为NULL</span><br><span class="line">    		m_String=NULL;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String &amp; String::operator =(const String &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">    	if(this==&amp;other)                   //如果对象与other是同一个对象</span><br><span class="line">    	&#123;</span><br><span class="line">    		return *this;                  //直接返回本身</span><br><span class="line">    	&#125;</span><br><span class="line">    	delete [] m_String;</span><br><span class="line">    	m_String=new char[strlen(other.m_String)+1];</span><br><span class="line">    	strcpy(m_String,other.m_String);</span><br><span class="line">    	return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">    	String a(&quot;hello&quot;);           //调用普通构造函数</span><br><span class="line">    	String b(&quot;word&quot;);            //调用普通构造函数</span><br><span class="line">    	String c(a);                 //调用复制构造函数</span><br><span class="line">    	c=b;                         //调用赋值函数</span><br><span class="line">    	return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="v模型">V模型</h3>
<ul>
<li><img src="https://admirelotusimagebed.oss-cn-hangzhou.aliyuncs.com/images/image-20220410141125929.png" alt="image-20220410141125929" style="zoom:50%;" /></li>
<li><strong>单元和集成测试是验证程序设计</strong>，单元测试主要由白盒测试工程对代码进行测试。<strong>系统测试主要验证系统设计</strong>，检测系统功能、性能的质量特性是否达到系统设计的指标。<strong>验收测试</strong>对需求进行测试。</li>
<li>单元测试验收的对象是详细测试说明书、集成测试验证的对象是概要设计说明书，系统测试验证的对象是需求说明书</li>
<li>V 模型最大的缺陷就是<strong>只把程序作为被测试对象</strong>，而<strong>需求、说明书等其他规格说明书</strong>都未被列为测试对象。</li>
<li>缺陷还有<strong>测试与开发是串行进行的而不是并行</strong>，也就是测试需要等开发完成后再开始</li>
</ul>
<h3 id="基础知识">基础知识</h3>
<ul>
<li>软件测试的对象包括：<strong>程序、数据、文档</strong></li>
</ul>
<h4 id="python-正则表达式">python 正则表达式</h4>
<ul>
<li><p>re.match: 是从字符串起始位置开始匹配一个模式</p></li>
<li><p>re.search: 扫描整个字符串返回第一个成功的进行匹配</p></li>
<li><p>re.sub: 进行替换</p></li>
<li><p>re.findall:匹配所有</p></li>
<li><p>re.split : 将能够皮欸的子串按照字符串分割返回列表</p></li>
</ul>
<h4 id="读文本文件的后n行">读文本文件的后n行</h4>
<h4 id="经典测试用例设计">经典测试用例设计</h4>
<ul>
<li><p>电梯 :</p>
<pre><code>**需求测试：**查看电梯使用说明书，安全说明书等。

 **功能测试：**

 1、**上升键和下降键**，电梯的楼层按钮是否正常；

 2、 **开关键**是否正常，报警装置是否安装，报警电话是否可用；

 3、通风状况如何，是否有手机信号；

 4、在电梯上升过程中的测试，比如电梯在1楼，有人按了18楼，在上升到5楼的时候，有人按了10楼，电梯会不会停；

 5、在电梯下降过程中的测试，比如电梯下降到10层时显示满员，若有人在5楼等待，此时还会不会停。

 **压力测试：**</code></pre>
<p>​ 看电梯的最大承重重量，在电梯超重时，报警装置是否启用，在一定时间内让电梯连续的上升和下降，看在最大负载条件下平稳运行的时间。</p>
<pre><code> **界面测试：**

 查看电梯的外观，电梯的按钮是否好用(开和关按钮设计的图标不容易区分)，电梯的说明书是否有错别字。

 **可用性测试：**

 电梯的按钮是否符合人的使用习惯。

 **用户文档：**

 使用手册是否对电梯的使用，限制等有描述。</code></pre></li>
<li><p><strong>杯子</strong></p>
<p><strong>需求测试：</strong>查看杯子的使用说明书，安全说明书等。</p>
<pre><code> **功能测试：**

 1、杯子**能否装水**；

 2、可以**装多少L**的水；

 3、杯子**是否可以放冰箱**；

 4、**水可不可以被喝到**。

 **安全性测试：**

 1、杯子有没有**毒和细菌**；

 2、杯子**从高处坠落**，是否已破；

 3、杯子**是否有缺口**，容易滑倒嘴巴；

 4、将杯子**放入微波炉**中，是否爆炸或融化；

 **性能测试：**

1、看杯子能够容纳的最大体积和最高温度；

 2、将杯子盛上水，经过24小时后查看杯子的泄露情况和时间(可分别使用水和汽油做测试)；

 3、将杯子装上填充物，看不会摔破的最高度；

 4、用根针并在针上面不断加重量，看压强多大时会穿透； 

 **可用性测试：**杯子是否好拿，是否烫手，是否防滑，是否方便饮用。

 **兼容性测试：**除了装水，是否还可以装其它的液体，比如果汁，汽油等。

 **界面测试：**查看杯子的外观：杯子是什么材质的，颜色，外形，重量，图案是否合理，是否有异味。

**用户文档：**使用手册是否对杯子的用法、限制、使用条件等有详细描述。</code></pre></li>
<li><p>笔</p>
<p>1、需求测试：查看使用说明书。</p>
<pre><code>2、功能测试：能不能写字 。

3、界面测试：查看笔的外观 。
4、可靠性：笔从不同高度落下摔坏的程度。 

5、安全性：笔有没有毒或细菌 。
6、可移植性：笔在不同的纸质、温度等环境下是否可以使用。 

7、兼容性：笔是否可以装不同颜色、大小的笔芯 。

8、易用性：是否方便使用、方便携带 。
9、压力测试：给笔不断的增加重力，观察压力多大时压坏。 
10、震动测试：笔在包装时，各面震动，检查是否能应对恶劣的公路、铁路、航空运输。

11、跌落测试：笔包装时，在多高的情况下摔不坏。</code></pre></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://despairl.github.io/2022/04/06/%E6%B8%B8%E6%88%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yanquan Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQBlog | HaveFun!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/%E6%B8%B8%E6%88%8F/" class="post-title-link" itemprop="url">Game!!!</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-06 00:00:00 / Modified: 21:49:40" itemprop="dateCreated datePublished" datetime="2022-04-06T00:00:00+08:00">2022-04-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Game/" itemprop="url" rel="index"><span itemprop="name">Game</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="年玩过的游戏">2022年玩过的游戏</h4>
<h5 id="艾尔登法环">艾尔登法环</h5>
<p>​ <img src="https://admirelotusimagebed.oss-cn-hangzhou.aliyuncs.com/images/image-20220406205852887.png" alt="image-20220406205852887" style="zoom:50%;" /></p>
<ul>
<li>应该是第一个刷新了我对于开放世界认知的游戏：
<ul>
<li>地牢的设计是最为拉胯的，但是几乎对于每个地牢仍然有不同的设计，先不说泥头车可躲可打可骑乘，影响较深的是几个利用重复一样的地形诱导玩家的地牢，正解的设计让人拍案叫绝——电梯隐藏、传送宝箱通向场景布置相同但实际不同的地牢、雪山左半初始道路的透明桥。</li>
<li>其次是开放世界的场景布置，有设计的堆料已经是前无古人后无来者的程度了。每个区域都是风格截然不同的设计，没有问号指引但是玩家所经过的每一个点几乎都有可探索的内容。这与刺客信条的设计理念是完全不同的，育碧想通过公式化喂饱玩家，而实际上英灵殿我玩完主线实在是不想再碰这类游戏了；宫崎英高呢，他说我不要，我要让玩家自己去探索，我更喜欢这种开放世界的模式，如果一个开放世界不能让玩家自己决定什么时候去哪里干什么，那它就根本不开放。</li>
<li>最让人难以忘怀的是几个主城的箱庭设计，单就初始城宁姆格福而言，不管是正常走的路线，还是通过别样的跳楼顶路线走的楼顶从而发现新大陆，甚至是跳脱出常规思路需要勇敢跳下悬崖才能抵达的地底一层，都让人游玩过程中情不自禁地感叹于设计之精妙。之后的学院、火山府邸也是隐藏道路、楼顶道路、正常路线完全契合在一起，这一点也许需要玩家自己去体验一遍才能感受到什么tm的叫做设计。最让我喜欢的场景是王城以及圣树，整个就是一把子震撼住。</li>
<li>唯一要提及影响了一点游玩体验的就是boss战，难以体验到过招的感觉，如果想要爽快就只能将强力战技、骨灰全部一股脑儿用上才行。虽然我尚未玩过过往的魂游、只狼，但我觉得空洞骑士过招拆招的boss体验更好一些。</li>
<li>优化导致的卡顿问题在禁用EAC之后基本得到解决。</li>
</ul></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://despairl.github.io/2022/04/05/Pattern_Recognition3.31/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yanquan Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQBlog | HaveFun!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/05/Pattern_Recognition3.31/" class="post-title-link" itemprop="url">2022.3.31 Pattern Recognition Note</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-05 23:37:42" itemprop="dateCreated datePublished" datetime="2022-04-05T23:37:42+08:00">2022-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-06 13:18:49" itemprop="dateModified" datetime="2022-04-06T13:18:49+08:00">2022-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ML-Note/" itemprop="url" rel="index"><span itemprop="name">ML Note</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="generative-models">Generative models</h3>
<p>估计联合概率 P(x,y) = P(x|y = i) P (y)</p>
<h3 id="discriminative判别-models">Discriminative(判别) models</h3>
<p>直接估计后验概率</p>
<h3 id="discriminant-function">Discriminant function</h3>
<p>直接求一个能够将各类都分开的边界</p>
<h3 id="svm形式化-简化的思路-关键">SVM形式化 简化的思路 关键</h3>
<p>简化 ： 线性、可分、二类 margin 计算 : <span class="math display">\[
设投影到超平面上的投影点为x_{\perp},那么对于任意的一个样本点x，其距离向量为x - x_{\perp}。\\
margin的方向为\frac{w}{||w||},可以设margin大小为r.\\
那么有 x = x_{\perp} + r \frac{w}{||w||}\\
w^Tx + b= w^Tx_{\perp} + b + r \frac{w^Tw}{||w||}\\
f(x) = f(x_{\perp}) + r||w||\\
因为x_{\perp}在超平面上，所以f(x_{\perp})=0\\
所以r = \frac{|w^Tx + b|}{||w||}
\]</span> SVM问题就是最大化margin的最小值 <span class="math display">\[
\arg\max_{w,b} (\min_i (\frac{|w^Tx + b|}{||w||}))
\]</span> 这个式子有四个难点</p>
<ul>
<li><div class="line-block">| 绝对值 -&gt; 简化为 <span class="math inline">\(y_i (w^Tx + b)\)</span></div></li>
<li><p>||||范数</p></li>
<li><p>x / 0 的问题 -&gt; 简化为 <span class="math inline">\(\arg\max_{w,b} \frac{1}{||w||} \min y_i (w^Tx + b)\)</span> why？ <span class="math inline">\(\frac{|w^Tx + b|}{||w||}\)</span>上下同阶,因此对于最优解<span class="math inline">\((w^*,b^*)\)</span>，<span class="math inline">\(a(w^*,b^*)\)</span> 仍为最优解</p></li>
<li><p>的问题 -&gt; 简化为 如果<span class="math inline">\(y_i (w^Tx + b) &gt; 0\)</span>就判定为正类，同时限制<span class="math inline">\(\min y_i (w^Tx + b)\)</span>为1</p></li>
<li><p>那么问题就转换为了<span class="math inline">\(\arg\min_{w,b} \frac{1}{2} w^Tw\ s.t.y_i (w^Tx + b) \ge 1,\forall i\)</span></p></li>
<li><p>利用拉格朗日乘子法、KKT条件求解。</p>
<ul>
<li>对偶形式 : <span class="math display">\[
  \arg\max_{a} \sum_{i=1}^n a_i - \frac{1}{2}  \sum_{i=1}^n \sum_{j=1}^n a_i  a_j y_i  y_j x_i^T x_j \\
  s.t.\ a_i \ge 0 \\
  \sum_{i=1}^n a_iy_i = 0
  \]</span></li>
</ul></li>
</ul>
<h3 id="奇异值分解">奇异值分解</h3>
<p><span class="math display">\[
A = U\Sigma V^T\\
其中， UU^T = VV^T = I,\Sigma除对角线上的元素为奇异值外，其余均0\\
\Sigma = diag(\sigma_1,\sigma_2,...,\sigma_{\min(m,n)}), as A\in m\times n
\]</span></p>
<p>也就是说，我们可以通过奇异值分解来解决矩阵某一维极大，而另外一维较小的情况下的降维且保留矩阵信息的问题。</p>
<h3 id="特征值分解">特征值分解</h3>
<p><span class="math display">\[
A = W \Sigma W^{-1} \\
W由n个特征向量组成，\Sigma除对角线上的元素为特征值外，其余均0
\]</span></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://despairl.github.io/2022/04/05/Pattern_Recognition3.24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yanquan Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQBlog | HaveFun!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/05/Pattern_Recognition3.24/" class="post-title-link" itemprop="url">2022.3.24 Pattern Recognition Note</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-05 23:37:42" itemprop="dateCreated datePublished" datetime="2022-04-05T23:37:42+08:00">2022-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-06 13:18:39" itemprop="dateModified" datetime="2022-04-06T13:18:39+08:00">2022-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ML-Note/" itemprop="url" rel="index"><span itemprop="name">ML Note</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="特征归一化">特征归一化</h3>
<h4 id="每维度归一化">每维度归一化</h4>
<ul>
<li>数值不在一个取值范围，很容易让数值小的一维完全没用</li>
<li>稀疏数据需要特别处理，<strong>0往往还要输成0</strong>。</li>
</ul>
<h4 id="l2l1归一化">l2,l1归一化</h4>
<ul>
<li>希望每一行的样本的范数保持一致</li>
<li>l1归一化适用于非负特征，如果<span class="math inline">\(x_i\)</span>是直方图，经常是最佳的</li>
</ul>
<h4 id="z-scaler">Z-scaler</h4>
<ul>
<li>相信数据是高斯分布的</li>
</ul>
<h4 id="测试集归一化">测试集归一化</h4>
<ul>
<li><p>测试集<strong>寻找最大值、最小值、均值</strong>，是<strong>绝对绝对错误</strong>的。</p></li>
<li><p><strong>除了测试的时候，永远不要使用测试数据</strong></p></li>
<li><p>测试集要与训练集用一样的归一化， 要用<strong>训练集的最大值、最小值、均值来归一化</strong>!</p>
<ul>
<li><strong>保存训练集的参数</strong></li>
</ul></li>
<li><p><strong>交叉验证</strong>的时候也需要注意!</p>
<p>
          <!--noindex-->
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://despairl.github.io/2022/03/17/Pattern_Recognition3.17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yanquan Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQBlog | HaveFun!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/17/Pattern_Recognition3.17/" class="post-title-link" itemprop="url">2022.3.17 Pattern Recognition Note</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-17 14:24:24" itemprop="dateCreated datePublished" datetime="2022-03-17T14:24:24+08:00">2022-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-06 13:18:28" itemprop="dateModified" datetime="2022-04-06T13:18:28+08:00">2022-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ML-Note/" itemprop="url" rel="index"><span itemprop="name">ML Note</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="pca">PCA</h4>
<ul>
<li><p>PCA的<strong>数据要求</strong>：数据的<strong>内在维度是低于表面维度</strong>的，<strong>不是互相独立</strong>的。</p></li>
<li><p>PCA是用线性关系来降低维度的。</p></li>
<li><p><strong>零阶表示</strong>(Zero-dimensional representation, 一个PCA的引子) :</p>
<ul>
<li><p>寻找一个固定的constant m，使得 <span class="math display">\[
  J_1(m) = \min_m \sum_{i=1}^n ||x_i - m ||^2 \\
  m = \arg\min_m J_1(m) = \frac{1}{n} \sum_{i=1}^n  x_i
  \]</span></p></li>
<li><p>这样就不用任何维度，最佳表示了<span class="math inline">\(x\)</span></p>
<p>
          <!--noindex-->
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://despairl.github.io/2022/03/16/torch_note1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yanquan Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQBlog | HaveFun!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/16/torch_note1/" class="post-title-link" itemprop="url">Pytorch Note One</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-16 19:23:11 / Modified: 19:24:33" itemprop="dateCreated datePublished" datetime="2022-03-16T19:23:11+08:00">2022-03-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/torch-Note/" itemprop="url" rel="index"><span itemprop="name">torch Note</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="pytorch">Pytorch</h1>
<h2 id="library">Library</h2>
<p>pprint 可以让打印效果更加好看一点.</p>
<p>pytorch 是更为灵活的一个Tensorflow的alternative之一</p>
<h2 id="tensor">Tensor</h2>
<p>我们可以从一个python list出发，构建一个tensor. data type 以及 dimensions 都会自动转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = [ [0,1], [2,3] ]</span><br><span class="line">tensor_first = torch.tensor(data)</span><br><span class="line">pp.pprint(tensor_first) # result : tensor([ [0,1], [2,3] ])</span><br></pre></td></tr></table></figure>
<p>同样也可以用dtype指定数据类型，常用的为torch.bool torch.float torch.long</p>
<p>或者也可以使用 .float()等方法</p>
<p>还可以利用tensor.FloatTensor, tensor.LongTensor直接创建相应类型的tensor，则在NLP领域中非常有用</p>
<p>torch.tensor默认是float类型的</p>
<p>另外，当然也可以从numpy的array进行转换,利用torch.from_numpy()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">ndarray = np.array(data)</span><br><span class="line">x_numpy = torch.from_numpy(ndarray)</span><br></pre></td></tr></table></figure>
<p>最后，也可以通过另一个tensor进行初始化tensor</p>
<p>有四种方法， torch.ones_like(), torch.zeros_like(), torch.rand_like() (均匀分布 0-1), torch.randn_like() (正态分布)</p>
<p>要达成相同的效果，可以指定一个shape，利用torch.zeros(), torch.ones(), torch.rand(), torch.randn()</p>
<p>example :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shape = (4, 2, 2)</span><br><span class="line">x_zeros = torch.zeros(shape)</span><br></pre></td></tr></table></figure>
<p>torch.arange(end) : 创建一个 从 0 到 end-1 的tensor</p>
          <!--noindex-->
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://despairl.github.io/2022/03/16/torch_note2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yanquan Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQBlog | HaveFun!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/16/torch_note2/" class="post-title-link" itemprop="url">Pytorch Note Two</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-16 19:23:11 / Modified: 19:24:58" itemprop="dateCreated datePublished" datetime="2022-03-16T19:23:11+08:00">2022-03-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/torch-Note/" itemprop="url" rel="index"><span itemprop="name">torch Note</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="pytorch-官方文档">1. Pytorch 官方文档</h2>
<p><a target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/index.html">PyTorch documentation — PyTorch 1.9.1 documentation</a></p>
<h3 id="basic">1 .Basic</h3>
<ul>
<li><p>Optimizer 会根据计算好的梯度更新参数。</p>
<p>因此，在调用torch.optim中的方法之前需要进行梯度的计算。</p>
<p>基本的调用过程:</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss.backward() # 计算梯度</span><br><span class="line">optimizer.step() # 更新参数 例如 学习率，权重</span><br></pre></td></tr></table></figure></p>
<p>通常，需要在调用optimizer之前确定数据的存储位置。</p>
<p>这一步由torch.device完成:</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device = torch.device(&#x27;cuda&#x27; if torch.cuda.is_available() else &#x27;cpu&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>而pytorch的梯度会进行累计，因此通常在每一次epoch中都要进行梯度的清零，这一份工作交给了zero_grad:</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Backward and optimize</span><br><span class="line">optimizer.zero_grad()</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure></p>
<p>当我们需要对某一层的optimizer进行参数的特化:</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optim.SGD([</span><br><span class="line">      &#123;&#x27;params&#x27;: model.base.parameters()&#125;,</span><br><span class="line">      &#123;&#x27;params&#x27;: model.classifier.parameters(), &#x27;lr&#x27;: 1e-3&#125;</span><br><span class="line">            ], lr=1e-2, momentum=0.9)</span><br></pre></td></tr></table></figure></p>
<p>这意味着对于model.base用参数lr=1e-2,对于model.classifier自己用参数'lr': 1e-3。</p>
<p>但是，两个都采用参数momentum=0.9。</p>
<p>Optimizer的几个固有方法</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optimizer.load_state_dict # 读取参数</span><br><span class="line">Optimizer.state_dict # 返回optimizer的一个参数</span><br><span class="line">Optimizer.step # 进行一步参数的更新</span><br><span class="line">Optimizer.zero_grad # 设定所有tensor的梯度为0</span><br></pre></td></tr></table></figure></p>
<p>
          <!--noindex-->
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://despairl.github.io/2022/03/07/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yanquan Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQBlog | HaveFun!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/" class="post-title-link" itemprop="url">面试学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-07 19:03:21" itemprop="dateCreated datePublished" datetime="2022-03-07T19:03:21+08:00">2022-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-22 16:14:10" itemprop="dateModified" datetime="2022-03-22T16:14:10+08:00">2022-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Work-Note/" itemprop="url" rel="index"><span itemprop="name">Work Note</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="算法题">算法题</h5>
<ul>
<li><p>简单的二分查找中需要考虑的<strong>细节问题</strong>:</p>
<ul>
<li><p>如果取mid = (left + right) / 2,当数据量很大的时候，left + right就可能超过int的上界，此时，需要改变公式为mid = left + (right - left) / 2,这样的话，(right - left) / 2 与 left + (right - left) / 2操作都不会超过int的上界(且不用使用longlong,对于c/c++来说)。</p></li>
<li><p>mid不是所求的数，那么，就要去找[left,mid-1],[mid+1，right]中是否有，mid已经找过了。</p></li>
<li><p>该算法的缺陷就在于，如果给的有序数组是[1,2,2,2,3],target是2，那么我们就只能得到index=3</p>
<ul>
<li>我们可以通过在判断num[mid] == target的时候，可以灵活调整left，right来求左侧索引或者右侧索引</li>
</ul></li>
<li><p>尽量用elif 展开不用else</p></li>
<li><p>另外当数据量比较小的时候，<strong>其实O(n)的线性查找会更快</strong>一些。</p></li>
<li><p>找右边界:</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while i &lt;= j:</span><br><span class="line">            m = (i + j) // 2</span><br><span class="line">            if nums[m] &lt;= target: i = m + 1 #只要相等i就会右移直到第一个不是target</span><br><span class="line">            else: j = m - 1</span><br><span class="line">        right = i</span><br></pre></td></tr></table></figure></p>
<p>找左边界:</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while i &lt;= j:</span><br><span class="line">            m = (i + j) // 2</span><br><span class="line">            if nums[m] &lt; target: i = m + 1</span><br><span class="line">            else: j = m - 1 #只要相等j就会左移直到第一个不是target</span><br><span class="line">        left = j</span><br></pre></td></tr></table></figure></p></li>
<li><p>二分法专门用来解决排好序的数组中的搜索问题。打比方来说有一个缺失了一个元素的递增数组，我们要怎么搜索出来缺失元素? 二分,<strong>num[mid] == mid,说明在数组的左侧，i = mid + 1，反之，在右侧, j = mid + 1。</strong></p></li>
</ul></li>
</ul>
          <!--noindex-->
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://despairl.github.io/2022/03/07/ML-review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yanquan Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YQBlog | HaveFun!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/ML-review/" class="post-title-link" itemprop="url">chap.1/2 ML基础概念 review</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-07 10:57:05" itemprop="dateCreated datePublished" datetime="2022-03-07T10:57:05+08:00">2022-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-22 16:08:48" itemprop="dateModified" datetime="2022-03-22T16:08:48+08:00">2022-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ML-Note/" itemprop="url" rel="index"><span itemprop="name">ML Note</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="chap1">Chap1</h3>
<ul>
<li>机器学习主要研究的就是从计算机的<strong>数据</strong>当中<strong>产生模型的算法</strong>,亦即<strong>学习算法</strong>。这是一个<strong>归纳</strong>的过程，不同于<strong>基于基本事实推导出结论的演绎</strong>过程。也可以将该学习过程看成是一个<strong>在假设空间中进行搜索</strong>与<strong>训练集fit</strong>的假设的过程,换句话说，对于<strong>每一个特征</strong>，学习过程都是<strong>假设一个值</strong>，组合特征维度形成一个<strong>特征向量</strong>/<strong>评判标准</strong>，看<strong>是否与训练集fit</strong>。</li>
<li>对于不同的学习任务，我们一般将预测对象按照值是否离散，区分<strong>分类(离散值)</strong>、<strong>回归(连续值)</strong>,它们同属于监督学习。</li>
<li>无监督、半监督、监督学习、测试、聚类(无监督)概念不赘述。</li>
<li>归纳偏好(Inductive Bias):指的是<strong>机器学习的算法或者模型</strong>在学习过程中<strong>对于某种类型假设的偏好</strong>。<strong>如果一个机器学习算法没有归纳偏好，那它就没法告诉我们什么是确定有效的</strong>。如果是随机产生，那么，每次训练预测得到的结果都不一样，这显然不是我们想看到的。</li>
<li><strong>Occam剃刀</strong>:如果有多个假设的结果一致，就选最简单的那一个</li>
<li><strong>天下没有免费的午餐(NFL)</strong>:所有学习算法的期望都是一样的。</li>
</ul>
<h3 id="chap2">Chap2</h3>
<ul>
<li><strong>过拟合</strong>:模型的复杂程度超过了数据的复杂程度
<ul>
<li>想要解决比解决欠拟合要复杂地多。</li>
</ul></li>
<li><strong>欠拟合</strong>:模型的复杂程度未超过了数据的复杂程度
<ul>
<li>克服? : 增加训练轮数即可。</li>
</ul></li>
<li>测试集的划分:
<ul>
<li><strong>hold-out 留出法</strong> : <strong>直接将数据集划分为训练集与测试集</strong>。比例把控不当会导致测试或者训练效果不佳。</li>
<li><strong>k-fold Cross Validation 交叉验证法</strong> :将数据集对等地<strong>划分为n折</strong>。 取其中<strong>一折作为测试集</strong>，其余的作为训练集。</li>
<li><strong>Bootstrap Sampling 自助法</strong>: 为了解决<strong>划分测试集导致的训练集复杂度降低</strong>的问题。该方法是<strong>在m个样本的数据集中随机有放回地采样m次</strong>构成新数据集<span class="math inline">\(D^\prime\)</span> 作为训练集，将<span class="math inline">\(D/D^\prime\)</span>作为测试集。在数学上可以证明，大概有36.8%的数据被划入了测试集。</li>
<li>总结: 一般来说，Bootstrap Sampling用于<strong>集成学习或者数据量较小</strong>的情况，另外两种可用于<strong>数据量较大</strong>的情况。</li>
</ul></li>
<li>错误率、精度、查准、查全、PR曲线、平衡点(BER)、F1度量</li>
<li>偏差-方差分解(<strong>bias-varience decompose</strong>):
<ul>
<li>定义泛化误差为<span class="math inline">\(E = bias^2(x) + var(x) + noise^2\)</span></li>
<li><span class="math inline">\(bias(x)\)</span> 描述期望预测与实际结果之间的矛盾，即<strong>模型本身的学习能力</strong></li>
<li><span class="math inline">\(var(x)\)</span> 描述<strong>数据扰动带来的影响</strong></li>
<li><span class="math inline">\(noise^2\)</span> 描述了学习问题泛化误差的下界，表示<strong>问题自身的复杂度</strong></li>
<li>偏差与方差存在冲突，训练前期，<strong>学习能力较差，不足以学习数据的扰动</strong>，就会<strong>由偏差主导泛化误差</strong>；训练后期，<strong>模型能够学习数据中的扰动</strong>，就会由<strong>方差主导泛化误差</strong>；当学习能力强到一定程度，<strong>极小的数据扰动带来的局部性质都被模型学习到了</strong>，就会出现<strong>过拟合</strong>。</li>
</ul></li>
</ul>
<h3 id="chap3">Chap3</h3>
<ul>
<li>线性模型:
<ul>
<li>尝试学习一个<strong>线性组合函数</strong>作为预测函数。</li>
<li>具有<strong>良好的可解释性</strong>，通过权重矩阵<span class="math inline">\(w\)</span>,可以直观地看出哪个属性更为重要。</li>
<li>通过引入<strong>层级结构或者高维结构</strong>就可以完成非线性。</li>
</ul></li>
<li>线性回归 ： 尝试学习一个线性组合函数作为预测函数, 预测标签。
<ul>
<li>采用<strong>最小二乘法（MSE最小化）</strong>的优化方法。</li>
</ul></li>
<li><strong>对数线性</strong>回归：将线性回归预测的<span class="math inline">\(y-&gt;\ln y\)</span></li>
<li><strong>对数几率</strong>回归：用Sigmoid进行预测，实际上是<strong>分类模型</strong>。
<ul>
<li><strong>Sigmoid任意阶可导</strong>，可以<strong>获得近似概率分布</strong>，<strong>有利于求最优解</strong>与<strong>辅助决策</strong>。</li>
<li><strong>不需要直接对数据分布做出假设</strong>，线性回归就会假设数据分布满足线性，但是对数几率回归<strong>对于分类的可能建模</strong>，<strong>数据不敏感</strong>。</li>
<li>用<strong>极大似然法</strong>进行优化处理,<strong>梯度下降</strong>求最优解。</li>
</ul></li>
<li>线性判别分析(LDA):
<ul>
<li><strong>同类</strong>尽可能接近（<strong>协方差小</strong>），<strong>异类</strong>尽可能远离（<strong>距离大</strong>）。</li>
</ul></li>
<li>多分类：
<ul>
<li><strong>将若干个类作为正例，若干个作为反例</strong>。</li>
<li>常见分类策略: <span class="math inline">\(OvO,OvR,MvM\)</span></li>
</ul></li>
<li>类别不平衡:
<ul>
<li>欠采样（<strong>反例</strong>）、过采样（<strong>正例</strong>）、阈值移动（在决策阶段使用<strong>等式转换</strong>目标）
<ul>
<li>通过转换判断<span class="math inline">\(\frac{y}{1-y} &gt; \frac{m^+}{m^-}\)</span>,来判断时候预测为正例。</li>
</ul></li>
<li>改变loss函数</li>
</ul></li>
</ul>
<h3 id="chap4">Chap4</h3>
<ul>
<li>决策树：
<ul>
<li>缓解过拟合:
<ul>
<li>剪枝：预剪枝（<strong>展开子树</strong>是否会带来泛化性能的提升来决定）、后剪枝(先训练出一棵完整的树再考虑)。
<ul>
<li>预剪枝：<strong>时间开销少、容易欠拟合</strong></li>
<li>后剪枝：<strong>时间开销大、不容易欠拟合</strong></li>
</ul></li>
</ul></li>
<li>决策树要实现斜向划分是通过<strong>分段近似</strong>(对每一个区间段<strong>拟合一个线性函数</strong>)实现的。</li>
</ul></li>
</ul>
<h3 id="chap5">Chap5</h3>
<ul>
<li>MP神经元</li>
<li>感知机Perceptron : 由两层神经元组成,输出层为MP神经元，需要激活函数处理。</li>
<li>非线性：多层前馈神经网络(multi-layer feedforwaed neural network)
<ul>
<li>通过BP算法训练</li>
<li><strong>累计BP算法（用所有样本）与标准BP算法(只用一个样本)</strong>的区别类似于<strong>随机梯度下降(只用一个样本)与梯度下降（用所有样本）</strong>之间的区别。</li>
<li>折中：小批量的随机梯度下降/...</li>
</ul></li>
<li>跳出局部最优:
<ul>
<li><strong>模拟退火</strong> : 每一步<strong>以一定概率接受更差</strong>的结果、<strong>随机梯度下降</strong>、<strong>遗传算法</strong></li>
<li>这些算法基本都是启发式的，没有理论保证。</li>
</ul></li>
<li>DNN:
<ul>
<li>进行<strong>深度学习</strong>也可以理解为进行<strong>特征学习</strong>或者<strong>表示学习</strong>。</li>
<li><strong>增加隐藏层数目比增加隐藏层神经元个数往往更有效</strong>。</li>
<li>多隐藏层的神经网络<strong>难以用BP进行训练</strong>，<strong>梯度会发散不收敛</strong>。</li>
<li><strong>无监督逐层训练</strong>是一个有效手段:
<ul>
<li>每次训练一层隐藏节点，将<strong>上一层输出作为输入，本层输出作为下一层输入</strong>。上述过程也被称为“<strong>预训练</strong>”。预训练结束之后，再对整个网络进行<strong>微调(fine-tuning)</strong>。这就相当于<strong>基于局部较优的结果组合寻找全局最优</strong>。</li>
</ul></li>
<li>在<strong>CNN</strong>中采用了<strong>权值共享</strong>的策略，让<strong>一组神经元有相同的连接权值</strong>。</li>
</ul></li>
</ul>
<h3 id="chap6">Chap6</h3>
<ul>
<li>SVM:
<ul>
<li><p>基于训练集，找到一个超平面将不同的样本分开。</p></li>
<li><p>通过将超平面方程中的<span class="math inline">\(x\)</span>替换为<span class="math inline">\(\phi(x)\)</span>就可以实现非线性。</p></li>
<li><p><strong>软间隔</strong>: 为了解决 <strong>难以判断线性可分的结果是不是过拟合</strong>造成的， 提出<strong>软间隔</strong>来缓解这一问题。</p>
<ul>
<li>软间隔将<strong>允许SVM在一些样本上出错</strong></li>
<li>优化目标就变成 在<strong>最大化间隔</strong>的基础上，<strong>最小化出错样本</strong>。</li>
<li>引入的<strong>松弛变量</strong>是为了表述<strong>样本不满足约束</strong>的程度,其实就是每个样本的<strong>loss</strong></li>
<li>引入软间隔之后，仍然超平面仍然<strong>仅与支持向量有关</strong>，<strong>保持了稀疏性</strong>。</li>
</ul></li>
<li><p>如果将软间隔的SVM的<strong>惩罚函数</strong>换为<span class="math inline">\(l_{log}\)</span> ,那么SVM（未经过拓展的情况下）就是一个<strong>二分类的对率回归分类器</strong>。 区别在于，<strong>对率回归可以输出概率</strong>，<strong>SVM不能</strong>；<strong>SVM的解具有稀疏性</strong>，<strong>对率回归依赖于样本</strong>，<strong>训练开销更大</strong>。</p></li>
<li><p>从SVM可以引出正则化问题：</p>
<ul>
<li><p><span class="math display">\[
  \min_f \Omega(f) + C \sum_{i=1}^m l(f(x_i),y_i)
  \]</span></p></li>
<li><p><span class="math inline">\(\Omega(f)\)</span>为<strong>正则化项</strong>，亦称<strong>结构风险</strong>，<span class="math inline">\(C\)</span>为<strong>正则化系数</strong>，<span class="math inline">\(\sum_{i=1}^m l(f(x_i),y_i)\)</span>也被称为<strong>经验风险</strong>。</p>
<ul>
<li>结构风险主要描述的是模型的特质</li>
<li>经验风险描述模型的拟合程度</li>
<li>正则化其实<strong>就是一种惩罚措施</strong>，对不希望出现的结果<strong>添加了一个惩罚项</strong>。从贝叶斯估计的角度来看，正则化给模型<strong>提供了先验概率</strong>。</li>
</ul></li>
<li><p>常用的正则化项为<span class="math inline">\(l_p\)</span>范数</p>
<ul>
<li><span class="math inline">\(l_2\)</span>范数倾向于<strong>权重的取值尽量均衡</strong>，<strong>非零分量尽量稠密</strong>，彼此的距离尽量小；<span class="math inline">\(l_1\)</span>范数倾向于<strong>非零分量尽可能少</strong></li>
</ul></li>
</ul></li>
</ul></li>
<li>表示定理、核方法、KLDA</li>
</ul>
<h3 id="chap7">Chap7</h3>
<ul>
<li><p>贝叶斯判定准则:</p>
<ul>
<li>最小化总体风险，只需在每个样本上选择能<strong>最小化期望损失的标签</strong>即可</li>
<li>由此得到<strong>贝叶斯最优分类器</strong></li>
<li>其优化目标等价于最大化 后验概率<span class="math inline">\(P(c|x)\)</span>。
<ul>
<li>由贝叶斯定理，可以转换为最大化<span class="math inline">\(\frac{P(c)P(x|c)}{P(x)}\)</span></li>
</ul></li>
</ul></li>
<li><p>而<strong>概率模型训练的过程就是参数估计</strong>的过程，一般采用极大似然估计的方法。</p></li>
<li><p>朴素贝叶斯分类器:</p>
<ul>
<li><p>假设所有属性独立产生影响。</p></li>
<li><p>那么对于一个样本，优化目标为</p>
<ul>
<li><span class="math display">\[
  \arg\max_x P(c) \prod_i P(x_i|c)
  \]</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="chap8">Chap8</h3>
<ul>
<li>Bagging :
<ul>
<li>目标在于<strong>减少方差</strong></li>
<li>Bagging使用<strong>Bootstrap随机有放回的抽样来获取数据子集</strong>训练基础学习器。通常<strong>分类</strong>任务使用<strong>投票</strong>的方式集成，而<strong>回归</strong>任务通过<strong>平均</strong>的方式集成。</li>
<li>Bootstrap剩下的36.8%的数据可以用来<strong>包外估计</strong>，<strong>辅助决策树剪枝</strong>，<strong>提前结束神经网络训练</strong>等。</li>
<li>适合用于<strong>决策树、神经网络等容易受到样本扰动</strong>的学习器上。</li>
</ul></li>
<li>Boosting
<ul>
<li>目标在于<strong>减少偏差</strong></li>
<li><strong>通过算法集合将弱学习器转换为强学习器</strong></li>
<li><strong>训练一系列的弱学习器</strong>，所谓弱学习器是指仅比随机猜测好一点点的模型，例如较小的决策树，训练的方式是<strong>利用加权的数据</strong>。在训练的早期<strong>对于错分数据给予较大的权重</strong>。</li>
<li><strong>每一轮的训练集是不变的</strong>，<strong>改变的只是每一个样本的权重</strong>。</li>
<li><strong>样本权重</strong>：<strong>Bagging</strong>使用的是<strong>均匀取样</strong>，每个样本权重相等；<strong>Boosting根据错误率调整样本权重，错误率越大的样本权重越大</strong>。</li>
<li>因此，Boosting与Bagging的区分点在于 <strong>训练集以及样本权重</strong></li>
</ul></li>
<li><strong>串行集成方法</strong>: AdaBoost, 也就是说AdaBoost依次训练弱学习器，
<ul>
<li>学习器之间有强依赖。一般是Boosting。</li>
</ul></li>
<li><strong>并行集成方法</strong>: Random Forest
<ul>
<li>一般是Bagging、随机森林。</li>
</ul></li>
<li><strong>AdaBoost</strong>:
<ul>
<li>通过<strong>线性组合基学习器来最小化指数损失</strong>。</li>
<li>AdaBoost在经过一个时间步<span class="math inline">\(H_t\)</span>之后，<strong>样本分布将进行调整</strong>(<strong>序列采样</strong>)，<strong>使得下一轮基学习器能够纠正上一轮基学习器的错误</strong>。</li>
</ul></li>
<li><strong>随机森林</strong>:
<ul>
<li><strong>决策树作为基学习器</strong>，利用<strong>Bagging集成</strong>,引入了<strong>随机属性选择(只选择一个属性子集，与SGD/GD的区别类似)</strong>。</li>
<li><strong>训练效率、结果更好</strong>。</li>
</ul></li>
<li>集成的权重结合方法:
<ul>
<li>投票、平均、加权投票、加权平均、<strong>学习法（Stacking）</strong>。</li>
</ul></li>
<li><strong>Stacking:</strong>
<ul>
<li>它是一种<strong>“学习法”</strong>的代表，<strong>与Bagging,Boosting不在一条赛道</strong>上。</li>
<li>目标在于<strong>提升预测性能</strong></li>
<li><strong>异质集成,将多个不同类的学习器集合到一起</strong>。</li>
<li>先从<strong>初始数据集中训练出一个初级学习器</strong>，然后将<strong>初级学习器的输出融入特征</strong>作为<strong>次级学习器</strong>的输入。</li>
<li>其缺点在于<strong>次级</strong>学习器<strong>容易过拟合</strong>，因此常常使用<strong>交叉验证法</strong>或者<strong>留一法</strong>。</li>
</ul></li>
<li>多样性:
<ul>
<li>衡量<strong>不同学习器</strong>之间是否<strong>好而不同</strong>。</li>
<li>要增强多样性，可以在<strong>数据、参数、特征等</strong>不同角度进行调整。</li>
</ul></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yanquan Chen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Yanquan Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/DespairL" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;DespairL" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Chen61723827" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Chen61723827" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yanquan Chen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
